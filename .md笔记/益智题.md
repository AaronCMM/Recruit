> // 插播一个常识 
>
> 2^10 Byte = 1024 Byte = 1KB 
>
> 2^30 Byte =  = 1024 * 1024 * 1024 Byte = 1GB



### 1】生成随机数问题：给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？

```
RandNN= N( RandN()-1 ) + RandN() ;  // 生成1到N^2之间的随机数
可以看作是在数轴上撒豆子。N是跨度/步长，是RandN()生成的数的范围长度，RandN()-1的目的是生成0到N-1的数，是跳数。后面+RandN()的目的是填满中间的空隙
```

比如：5 * (Rand5( ) - 1) + Rand5( ) ;   （可以得到 1~25 的数）

// Rand5 产生1 ~ 5的数，减1就产生0~4的数，乘以5后可以产生的数是：0,5,10,15,20。 再加上第二个Rand5()产生的1,2,3,4,5。我们可以得到1到25。

我们可以只要1到21（3*7）之间的数字，所以可以这么写

```
int rand7(){
  int x=INT_MAX;
  while(x>21){  // 此时会抛弃 22,23,24,25 这4个数
    x=5*(rand5()-1)+rand5();
  }
  return x%7+1;
}

# 优化，尽可能少的抛弃数
int rand7(){
  int x=INT_MAX;
  while(true){
    x=5*(rand5()-1)+rand5();
    if(x<=21) retrun x%7+1;
    x=(x-21-1)*5 +rand5();  // 说明产生了 22-25的数，用这些数，再随机生成一遍
  }
  return x%7+1;
}
```

### 2】如果你有两个桶，一个装的是红色的颜料，另一个装的是蓝色的颜料。你从蓝色颜料桶里舀一杯，倒入红色颜料桶，再从红色颜料桶里舀一杯倒入蓝颜料桶。两个桶中红蓝颜料的比例哪个更高？通过算术的方式来证明这一点。

假设桶各有10L颜料，满瓢为1L。

- 第一次操作后。蓝桶有9L，100%纯度，红桶有11L，10/11 = 90.91%纯度。
- 第二次操作后，蓝桶有10L，((10/11)*(1/10)) / 10 = 10/11=90.91%纯度。

<font color=purple>**所以是一样多的。**</font>



### 3】有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？

**至少2次**：第一次，一边3个，哪边轻就在哪边，一样重就是剩余的3个；
第二次，一边1个，哪边轻就是哪个，一样重就是剩余的那个；

### 3.2】进阶版（字节一面）：有一个天平，九个砝码，一个可能重也可能轻，用天平至少几次能找到这个异常的？

**至少3次**：

第一次：一边放3个，假设第一次：A轻，B重

第二次： 将 剩下的C 和A称，如果这时候还是：A轻，C重；

则说明 A堆中的3个小球里有一个是偏轻的小球。（前两次主要用来 判断这个异常球是重还是轻。）

第三次：一边一个，哪边轻就是哪个。

### 4】无限抛硬币,一正一反A赢,两反B赢,求A赢概率

<font color=red size=4>答案为：3/4</font>

解析：    A赢的条件是：正反；B赢的条件是：反反 

>   **从第一次抛硬币开始计算** 
>
>   假设第一次是:正，概率是1/2 
>
>   第二次如果是 反 则A赢，如果是正，则都不赢，继续抛，直道出现 反 也就是A赢为止。 
>
>   也就是说在第一次结果为 正 的情况下A必赢 
>
>  
>
>   假设第一次是：反，概率是1/2 
>
>   第二次如果是 反 则B赢，概率是1/2，如果是 正 则又出现A必赢的情况 
>
> 
>
>   所以A赢的概率是1/2+(1/2)*(1/2)=3/4 
>
>   B赢的概率是(1/2)*(1/2)=1/4



### 5】烧 香/绳子/其他 确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？

（说了求15分钟，没说开始的15分钟还是结束的15分钟，这里是可以求最后的15分钟）点燃一根A，同时点燃另一根B的两端，当另一根B烧完的时候就是半小时，这是再将A的另一端也点燃，从这时到A燃烧完就正好15分钟。



### 6】数据库中如何存储 像身份证号这样长的字符串？如何提高效率？(字节data一面)

​		身份证号后六位最具辨证度，可以只存储身份证的后6位，减少字段长度，减轻数据库压力。

### 7】 先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿

​		寻找每个回合固定的拿取模式。最后一次是我拿，那么上个回合最少剩下6本。那么只要保持每个回合结束后都剩下6的倍数，并且在这个回合中我拿的和对方拿的加起来为6（这样这个回合结束后剩下的还是6的倍数），就必胜。关键是第一次我必须先手拿  

最终答案：（ 100%6 = 4 ）本（这不算在第一回合里面）。



### 8】 8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）

https://blog.csdn.net/ailunlee/article/details/84548950

![img](https://img-blog.csdnimg.cn/20181126161926976.jpeg)

排序的时候可以选择**快速排序**或**归并排序**等算法。为了方便，我们把排序好的2G有序数据称为有序子串。接着把两个小的有序子串合并成一个大的有序子串。

![img](https://img-blog.csdnimg.cn/20181126161926964.jpeg)

<font size=4>总结：</font>

​		可以使用外部排序来对它进行处理。首先将整个文件分成许多份，比如说m份，划分的依据就是使得每一份的大小都能放到内存里。然后我们用快速排序或者堆排序等方法对每一份数据进行一个内部排序，变成有序子串。接着对这m份有序子串进行m路归并排序。取这m份数据的最小元素，进行排序，输出排序后最小的元素到结果中，同时从该元素所在子串中读入一个元素，直到所有数据都被输出到结果中为止。

### 9】大文件，每行一个字符串，找出第一个重复的字符串

​		<font size=4 color=blue>字符串可以构成**字典树**。</font>每次查询字符串要么新加到字典树上，要么已经存在的。也可以把字符串转成 md5码放在 hash里查询。

#### 字符串改成 UINT32呢？多大内存？

​		uint 32 用哈希找。内存= 行数* md5码的大小 /   行数* uint32 大小；

### 10】一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。

  	方案1：如果文件比较大，无法一次性读入内存，可以采用hash取模的方法，将大文件分解为多个小文件，对于单个小文件利用hash_map统计出每个小文件中10个最常出现的词，然后再进行归并处理，找出最终的10个最常出现的词。

​	<font size=4 color=red>**方案2**</font>：通过hash取模将大文件分解为多个小文件后，除了可以用hash_map统计出每个小文件中10个最常出现的词，**也可以用trie树统计每个词出现的次数，时间复杂度是O(n * le)**（le表示单词的平准长度），最终同样找出出现最频繁的前10个词（可用堆来实现），时间复杂度是O(n*lg10)。

### 11】在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。

<font size=4 color=blue>采用2-Bitmap</font>（每个数分配2bit，**00表示不存在，01表示出现一次，10表示多次，11无意义**）进行，共需**内存2^32 * 2 bit=1 GB**内存，还可以接受。<font size=4 color=blue>扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看 bitmap，把对应位是01的整数输出即可。</font>



富途面试题：

【1】100万人口的城市，城东20万，城西80万，一天会发生一百万次通信，求发生跨城区通信的次数

<img src="https://uploadfiles.nowcoder.com/message_images/20210405/188871214_1617589040169/discuss_1617589039158.jpeg?x-oss-process=image%2Fresize%2Cm_mfit%2Cw_550%2Ch_550" alt="discuss_1617589039158.jpeg" style="zoom:67%;" />

【2】 52张扑克牌抽两张相同颜色的概率

<img src="https://iknow-pic.cdn.bcebos.com/77094b36acaf2edd1a6cc4468b1001e938019384?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1/quality,q_85/format,f_jpg" alt="img" style="zoom:67%;" />

【3】一个40亿的数据存储，但是你只有1G内存，怎么存

<font size=4 color=blue>用 bitmap 存储</font>

【4】三个箱子，分别贴有苹果、梨子、苹果+梨子，但是箱子里装的水果一定不是标签那个，如何只拿一个，就能将标签全部贴对？（有意思）

> 从标签是 ”苹果+梨子“的盒子里面取出来一个水果，假设是苹果，由于标签是错误的。那么这个盒子里装的只有就是苹果，第一个盒子已经确认了。
> 2、那就剩下标签“苹果”和标签是“梨子”的盒子。由于标签是错误的，那么标签是“梨子”的里面肯定不是梨子，又由于第一步中苹果已经被确认了，那么标签是“梨子”的盒子里面装的就是梨子+苹果。



### 12】过河问题，A B C D四个人，单独过河分别需要1,2,5,10分钟，最多两个人同时过，并且只有一个手电筒，每次都需要电筒，两人过河按慢的时间算，问最少几分钟？

思路：

- ab   2 去
- a    1 返
- cd  10 去
- b   2 返
- ad   2 去

time：2 + 1 + 10 + 2 + 2 = 17分钟

K个人过河，同样的规则，方案是首先K个人排序，两个两个为一组，第一次，先让组合时间最小的队伍过河，然后在河对岸的人中找到用时最短的人把手电筒带回来。第二次就是第二小的组合，保证组合不变，每次带手电筒的人都是河对岸中，用时最少的人。大概是这么个思路，有待验证。



### 13】赛马问题 64匹马8个跑道最少几次赛出最快的4匹马

所以，<font color=blue size=4>最少10场，最多11场</font>

<img src="https://i.loli.net/2021/09/16/nmrBusD9Ioc1UP4.png" alt="在这里插入图片描述" style="zoom: 33%;" />

1、首先要赛8+1场，得到上表中的相对顺序
A1>A2>…>A8
B1>B2>…>B8
…
H1>H2>…>H8
A1>B1>…>H1

2、第2-4名只可能在红色区域出现（如：D2<D1<C1<B1<A1,所以D2一定不是前四）

红色区域共有9匹马，取出A2，让剩下8匹马赛一场，如果A3第一，则前4已经确定了共8+1+1=10场，如果A3不是第一，则还需要让这一场的前三名和A2赛一场，共8+1+1+1=11场



### 有25匹马和一个5个赛道的马场

<font color=blue size=4>选出：第一快需要6场、第二快需要7场、第三块需要8场</font>

## 36匹马6赛道

共6 + 1 + 1 = 8场

