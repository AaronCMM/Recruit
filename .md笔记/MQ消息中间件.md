# 消息中间件

https://blog.csdn.net/weixin_34402408/article/details/88837844?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-8.control&dist_request_id=1328689.11908.16165967865273119&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-8.control

https://blog.csdn.net/wqc19920906/article/details/82193316

###  消息中间件的组成

- <font color=purple size=4>**Broker：消息服务器（缓存代理）**</font>，作为 server 提供消息核心服务；
- <font color=purple size=4>**Producer**</font>：消息生产者，负责 生产消息传输给  broker；
- <font color=purple size=4>**Consumer**</font>：消息 消费者，负责从 broker 获取消息并进行业务逻辑处理。
- <font color=purple size=4>**Topic**：主题，发布订阅模式下的消息汇集地</font>。不同生产者 向 topic 发送消息，**由   MQ  服务器分发到不同的订阅者，实现 消息的广播；**（）
- <font color=purple size=4>**Queue**</font>：队列，PTP模式下，特定生产者 向 特定queue 发送消息，消费者订阅 特定的queue，完成指定消息的接收；
- <font color=purple size=4>**Message**</font>：消息体，根据不同消息协议定义的固定格式进行编码的数据包，来封装 业务数据，实现消息的传输。

### 消息中间件的模式分类

1. <font size=4 color=red>**PTP 点对点**</font>

   PTP 点对点使用  <font color=red>**queue 作为通信载体**</font>；生产者将消息发送到 queue，消费者从 queue 取数据；消息被消费后，不再存储。Queue 支持多个消费者，但只有一个 消费者可以消息；

2. <font size=4 color=red> **发布 / 订阅**</font>

   <font color=red>**使用 topic 作为 通信载体**</font>；生产者 将消息发布到  topic 上，同时有 多个消息者 订阅（消费）该消息。主题使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布/订阅模式在消息的一对多广播时采用。

   queue 实现了 负载均衡；topic 实现了 发布订阅，所有 1 到 N个订阅者都能得到一个消息的拷贝。

### 为什么要用消息中间件？

<font size=4 color=blue>低耦合（系统解耦），低响应时间，异步调用。</font>

- <font color=red>异步处理：</font>

- 冗余：<font color=red>**消息队列 把数据进行持久化直到它们已经被完全处理，规避了  数据丢失风险。**</font>

- 可恢复性：**消息队列降低了进程间的耦合；即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理**。

- <font color=red>**流量削峰（重点）**</font>：（在   应用前端 加入 消息队列）

  - **可以控制活动人数，超过此一定阀值的订单直接丢弃**(我为什么秒杀一次都没有成功过呢^^)
  - 可以**缓解短时间的高流量**压垮应用（**应用程序按自己的最大处理能力获取订单**）

  

### 消费模式（腾讯一面问过）

消费模式分为<font size=4 color=blue>推（push）模式和拉（pull）模式</font>。<font color=red>**推（push）模式**</font>是指由<font size=4 >Broker主动推送消息至消费端，**实时性较好**，不过需要一定的**流控制机制来确保服务端推送过来的消息不会压垮消费端**</font>。而  <font color=red>**拉（pull）模式**</font>   是指消费端主动向Broker端请求拉取（一般是定时或者定量）消息，实时性 较 推（push）模式  差，但是<font size=4 >**可以根据自身的处理能力 来控制拉取的消息量**</font>。

### 延迟队列

当你在网上购物的时候是否会遇到这样的提示：“三十分钟之内未付款，订单自动取消”？这是延迟队列的一种典型应用场景；

“延迟消息”  是指**当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费**；

延迟队列一般分为两种：**基于消息的延迟和基于队列的延迟**；

**基于消息的延迟**：为每条消息设置不同的延迟时间，那么每当队列中有新消息进入的时候就会重新根据延迟时间排序。

实际应用中大多采用**基于队列的延迟，设置不同延迟级别的队列**；每个队列中消息的延迟时间都是相同的

### 死信队列

由于某些原因消息无法被正确的投递，为了确保消息不会被无故的丢弃，一般将其置于 死信队列。

### 重试队列

**消费端消费消息失败时**，为防止消息无故丢失而重新将消息回滚到Broker中。重试队列一般**分成多个重试等级**，**每个重试等级设置重新投递延时，重试次数越多投递延时就越大。超过投递次数就入死信队列。**

重试队列与延迟队列有相同的地方，都是需要设置延迟级别，它们彼此的区别是：<font color=blue>**延迟队列动作由内部触发，重试队列动作由外部消费端触发；延迟队列作用一次，而重试队列的作用范围会向后传递。**</font >

### 消息回溯

消息在消费完成之后，还能消费到之前被消费掉的消息。对于消息而言，经常面临的问题是“消息丢失"；如果消息中间件本身具备消息回溯功能的话，可以通过回溯消费复现“丢失的”消息进而查出问题的源头之所在。消息回溯的作用远不止与此，比如还有索引恢复、本地缓存重建。

### 消息堆积+持久化

流量削峰是消息中间件的一个非常重要的功能，而这个功能其实得益于其消息堆积能力；

**消息堆积分内存式堆积和磁盘式堆积**；**RabbitMQ是典型的内存式堆积**；**Kafka是一种典型的磁盘式堆积**，所有的消息都存储在磁盘中。一般来说，磁盘的容量会比内存的容量要大得多**，对于磁盘式的堆积其堆积能力就是整个磁盘的大小**。



# Kafka（典型的 发布/ 订阅模式）

#### 拓扑结构：

![img](https://img-blog.csdn.net/20180902105920995?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAwMjAwOTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### kafka 的特点：

1. **高吞吐**：同时为分布和订阅提供高吞吐量。据了解，Kafka每秒可以生产约25万条消息（50MB），每秒处理55万条消息（110MB）这里说条数，可能不是特别准确，因为消息的大小可能不一致；

2. **消息持久化**：**通过磁盘顺序读写**与零拷贝机制，可以在O(1)的系统开销下进行消息持久化；

3. **完全的分布式系统**，易于向外拓展。所有的Producer、broker和consumer都会有多个，均为分布式。依赖zookeeper自动实现复杂均衡。

4. **高堆积**：支持topic下**消费者较长时间离线**，消息堆积量大；

5. **消息被处理的状态是在consumer端维护，而不是由server端维护，当失败时能自动平衡。**

   

