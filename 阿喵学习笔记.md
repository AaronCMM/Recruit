# （一）语言基础 C++ 

### 面向对象和面向过程

- **面向过程（<font color=red>步骤化</font>），面向过程就是分析出实现需求所需要的步骤，通过函数（方法）一步一步实现这些步骤，接着依次调用即可。**
- **面向对象（<font color=red>行为化</font>）：将现实问题抽象成类，给类定义属性和方法后，再将类实例化成 实例 ，通过访问实例的属性和调用方法来进行使用。（特点：封装，继承，多态）** <font color=red> **对象 = 属性（特征）+ 方法（行为）**。</font>



### auto 和 decltype

<font size=4 color=purple>**auto 和 decltype 最主要的区别：**</font>

​	<font size=4 color=red>**1、对 CV 限定符的处理不同（ const 和 volatile ）**</font>

   <font size=4 color=purple>**decltype 会保留 cv 限定符，而 auto 有可能会去掉 cv 限定符。**</font>

<font size=4>对于 auto：</font>

- **如果表达式的类型不是指针或者引用，auto 会把 cv 限定符直接抛弃**，推导成 non-const 或者 non-volatile 类型。
- **如果表达式的类型是指针或者引用，auto 将保留 cv 限定符**。

```
//非指针非引用类型
const int n1 = 0;
auto n2 = 10;
n2 = 99;  //赋值不报错
decltype(n1) n3 = 20;
n3 = 5;  //赋值报错

//指针类型
const int *p1 = &n1;
auto p2 = p1;
*p2 = 66;  //赋值报错
decltype(p1) p3 = p1;
*p3 = 19;  //赋值报错
```

​	<font size=4 color=red>**2、对引用的处理不同**</font>

当表达式的类型为引用时，auto 和 decltype 的推导规则也不一样；

<font size=4 color=purple>**decltype 会保留引用类型，而 auto 会抛弃引用类型，直接推导出它的原始类型。**</font>

```
int main() {
    int n = 10;
    int &r1 = n;
    
    //auto推导
    auto r2 = r1;
    r2 = 20;
    cout << n << ", " << r1 << ", " << r2 << endl;
    
    //decltype推导
    decltype(r1) r3 = n;
    r3 = 99;
    cout << n << ", " << r1 << ", " << r3 << endl;
    
    return 0;
}
运行结果：
10, 10, 20
99, 99, 99
```

从运行结果可以发现，给 r2 赋值并没有改变 n 的值，这说明 r2 没有指向 n，而是自立门户，单独拥有了一块内存，这就证明 r 不再是引用类型，它的引用类型被 auto 抛弃了。

### constexpr 常量表达式

constexpr 修饰类成员变量时候必须要和 static 一起用。

因为它是个“常量”，从概念上说常量没有在struct里面占地方，所以它不是对象的成员。

<font size=4>**const其实是read only，constexpr 才是 const。**</font>



### 菱形继承的问题及其解决方式

```
class Base{
public:
    void fun(){
        cout<<"Base()"<<endl;
    }
};
class A:public Base{

};

class C:public Base{

};
class D:public A,public C{


};
int main(){
    D d;
    //d.fun(); 出错，返回request for member 'fun' is ambiguous
    d.A::fun();  
    d.C::fun();     // 利用域限定需要访问的函数
    return 0;
}
```

<font size=4 color=red>虚继承</font> ：**利用虚继承可以解决菱形继承的问题**，具体实现是：**A和C中不再保存Base的具体内容，而是保存了一份偏移地址**，所以在D调用fun()时，调用的就是Base的fun()，但对于A、C相同的变量名，D在调用时还是要利用域限定来处理。

```
class Base{
public:
    int _base=1;
    void fun(){
        cout<<"Base()"<<endl;
    }
};

class A:virtual public Base{
public:
    int _base=2;
};

class C:virtual public Base{
public:
    int _base=3;
};

class D:public A,public C{

};
int main(){
    D d;
    d.fun();						//Base()
    d.A::fun();						//Base()
    d.C::fun();						//Base()
    cout<<d.Base::_base<<endl;		//1
    cout<<d.A::_base<<endl;			//2
    cout<<d.C::_base<<endl;			//3
    return 0;
}
```

#### <font color=red>虚继承</font>

<font size=4 color=red>虚继承：解决多重继承的问题，多重继承会在子类存在多份拷贝（浪费存储空间，存在二义性）</font>

一般通过 <font color=blue>**虚基类指针+虚基类表**</font> 实现；**虚基类表中**，<font color=blue>**记录了虚基类与本类的偏移地址**</font>，**通过偏移地址，找到虚基类成员**。



#### public | protected | private 继承

不同的继承方式，决定 基类成员在 派生类中的 访问属性。

1. <font color=blue size=4>private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；</font>
2. <font color=blue size=4>protected 成员可以被派生类访问。</font>



### C语言中，局部变量未初始化，其值是随机的

**定义局部变量，其实就是在栈中通过移动栈指针来给程序提供一个内存空间和这个局部变量名绑定**。因为**这段内存空间在栈上，而栈内存是反复使用的**（脏的，上次用完没清零的），所以说使用栈来实现的局部变量定义时如果不显式初始化，值就是脏的。

对于未初始化的局部变量，它们的值取决于：

- <font color=blue size=4>变量在栈中的位置。</font>
- <font color=blue size=4>变量对应的栈位置在 之前 有没有被store过。</font>



### Python | C++

- C ++不提供垃圾回收并且在很大程度上使用指针，因此很容易发生内存泄漏。

- **内存管理的区别：Python具有内置的垃圾回收**

- <font color=red size=4>C++ 为什么比 Python 高效（重点）？</font>

  - **Python**的传统运行执行模式：**源代码转换为字节码**，之后**字节码在python虚拟机中运行**。代码自动被编译，之后**再解释成机器码在CPU中执行**。

  - **C 编译器直接把c源代码编译成机器码**。过程比python执行过程**少了字节码生成和虚拟机执行字节码过程**。

    

### 递归爆栈的解决方法（尾递归 | 值传递）

<font size=4 color=red>尾递归</font>

```
long Rescuvie(long n){
	return (n==1)? 1 : n * Rescuvie(n-1);
}
```

<font color=blue>传统递归方法如上</font>，每次活跃期的返回值都依赖与下一个活跃期的返回值，<font color=blue>因此每次调用产生的栈帧不得不保存在栈上直到下一个子调用的返回值确定</font>。

如果不用尾递归，函数的堆栈需要保存很多中间函数的堆栈。

```
long TailRescuvie(long n){
	return (n==0)? 1 : TailRescuvie(n, 1);    // 尾递归的实现，不需要依赖下一个递归的返回值；
}
long TailRescuvie(long n, long a){
	return (n==1)? a : TailRescuvie(n-1, a*n);
}
```

<font size=4 color=red>尾递归的优势：</font>

由于尾递归的调用处于方法的最后，因此方法之前所积累下的各种状态，对于递归调用的结果没有意义。**可以不用保留中间状态值。使得递归不会在调用堆栈上产生堆积。（控制栈的增长且减少压栈。依赖于编译器的优化）**



### 函数重载（形参类型+个数）的实现原理

编译器在编译 .cpp 文件时，**根据 函数形参的类型和顺序 会对函数进行重命名。**

在 Linux g++ 编译中，根据函数的形参类型+ 顺序的规则，重命名记录在符合表中。



### 1、==封装、继承、多态==

* **封装隐藏了类的实现细节和成员数据**，实现了代码模块化，如类里面的private和public；
* **继承使得子类可以复用父类的成员和方法**；
* **多态则是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用**，如**父类的指针指向子类的对象**

### 2、 程序编译流程：

​		预处理阶段-> 编译->汇编阶段->链接阶段    （https://blog.csdn.net/freeking101/article/details/78257914）

![image-20210312110209578](../AppData/Roaming/Typora/typora-user-images/image-20210312110209578.png)

> gcc [选项] 要编译的文件 [选项] [目标文件]   
>
>  其中，目标文件可缺省，gcc 默认生成可执行的文件名为：a.out   
>
>  gcc main.c    直接生成可执行文件 a.out 
>
> **gcc -E main.c -o hello.i**        生成预处理后的代码（还是文本文件) 
>
> **gcc –S main.c -o hello.s**        生成汇编代码  
>
> **gcc –c main.c -o hello.o**        生成目标代码 

<font color=red >**带参数的宏定义：**</font>

优点：提高程序的运行效率：**使用带参数的宏既代替了函数的功能，又避免了函数入栈和出栈操作，减少了系统的开销**，提高了运行的效率。

缺点：预处理阶段会展开所有的宏定义，会导致**目标代码空间变大**。



- <font color=red>**预处理：**</font>将源文件 根据预编译指令 修改成 .i 文件（**经过预编译的 .i 文件不包含任何宏定义**） ==gcc -E mian.c -o main.i==

  > ​	主要处理源代码文件中的以 **# 开始的预编译指令**，**如 #include、#define、#if，同时并删除注释行，还会添加行号和文件名标识**，以便于编译时编译器产生调试用的行号信息，及用于编译时产生编译错误或警告时能够显示行号。

  <font color=red>预处理会干什么事情：（文本替换、宏展开、删除注释）</font>

  - **展开所有的宏定义并删除 #define**
  - 处理所有的**条件编译指令**，例如 #if #else #endif #ifndef …
  - 把所有的 **#include 替换为头文件实际内容**，递归进行
  - 删除所有的注释行
  - 添加行号和文件名标识以供编译器使用
  - 保留所有的 #pragma 指令，因为编译器要使用

  

- <font color=red>**编译：**</font>将 .i 文件 翻译成 .s 文件（**汇编程序**）==gcc -S==

  > **词法分析** ---> **语法分析** ---> **语义分析及相关的优化** ---> 中间代码生成 ---> **目标代码生成**（**汇编文件.s**）。

  

- <font color=red>**汇编**</font>： 把编译阶段生成的 ”.s” 文件转成**二进制目标代码**。 ==gcc -c==

  > 汇编器（as）将 hello.s **翻译成机器语言指令**，把这些指令打包成一种叫做**可重定位目标程序的格式**，并将结果保存在目标文件hello.o中；注意：**hello.o文件是一个二进制文件**（**文件类型是ELF**），它的**字节编码是机器语言指令**而不是字符。如果我们在文本编译器中打开 hello.o 文件，看到的将是一堆**乱码**。

  <font color=blue>汇编生成的目标文件 .o 一般包含了哪些内容？</font>

  ​		编译后的<font color=red>机器指令代码、数据、连接所需的信息、符号表（链接的接口）、调试信息、字符串</font>等。

  ==**源代码被编译以后生成两种段<font color=blue>数据段和指令段</font>**，.code.text属于指令段；.data  .bss 都属于数据段。==

  **将 数据段和指令段 分开存储有以下好处：**

  1. 防止程序被有意无意篡改。这是因为指令段只读，数据段可读写。
  2. 提高了缓存命中率。
  3. 节省内存空间。因为指令段可被多个副本共享，但是副本可以拥有自己的数据段。

  

- <font color=red>**链接**</font>：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序
  
  对目标文件进行链接主要是：因为**在目标文件中可能用到了在其他文件当中定义的字段(或者函数**)**，**通过链接来把多个不同目标文件关联到一起。
  
  > 模块之间的通信有两种方式：**一种是模块间的函数调用**，另一种是**模块间的变量访问**。函数访问需知道目标函数的地址，变量访问也需要知道目标变量的地址，所以这两种方式都可以归结为一种方式，那就是**模块间符号的引用**。**链接过程中很关键的一部分就是符号的管理，<font color=red>每一个目标文件都会有一个相应的符号表</font>**。（<font color=red>函数名  和 变量名  就是符号名；符号值就是 它们的地址</font>）
  
  <font color=red>链接过程</font>主要包括了<font color=red>**地址和空间分配、符号决议（地址绑定）和重定位。**</font>
  
  - **静态链接**：**每个可执行程序对所有需要的目标文件都要有一份副本**，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件存在多个副本（空间浪费）；更新困难：当 修改代码时，需要重新编译链接。
  - **动态链接**：在**程序运行时才进行链接**。**共享库**（多个程序在执行时共享同一份副本）**更新方便**（更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。）

##### 2.2 **理解重定位：**

​		重定位的过程中，<font color=red>**每个重定位的入口都是对一个符号的引用**</font>，那么当链接器须要**对某个符号的引用重定位**时，它就是要<font color=red>**确定这个符号的目标地址**</font>。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。



### 2.3 区别以下指针类型

```
int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)
```

1. int *p[10]，指针数组；强调数组。数组内 每个元素都是指向 int类型的指针变量
2. int (*p)[10]，数组指针，强调指针。指向 int类型数组的一个指针
3. int *p(int)；函数声明，函数名是p，参数类型为int，返回类型为 int * 类型
4. int (*p)(int) 函数指针，强调指针；该指针 指向的函数具有 int 类型参数，并且返回值是 int型。

## 3、指针和数组、指针和引用

数组：「<font color=red>**存放在连续内存空间上**</font>的**相同类型数据**的集合。」

​		**那么==二维数组在内存的空间地址是连续的么==？**

> int[][] []  [] rating = new int [ 3 ] [ 4 ];
>
> 这个二维数据在内存空间中<font color=red>**不是一个 `3*4` 的连续地址空间**</font>

<img src="https://mmbiz.qpic.cn/mmbiz_png/F1VzfUpxxe6PbXB7UABWIylicgpBXscnxibbamymiau7aPRgzWkA2iaOGicMsRsJT6OeFmj9VW4L6Pyp1j5K4G7WwDg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

所以**「二维数据在内存中不是 `3*4` 的连续地址空间，而是三条连续的地址空间组成！」**

指针：某个变量的内存地址。

<font color=red>数组名被解释为 第一个元素的地址，而对数组名应用 地址运算符（&），得到的是，整个数组的地址。</font>

```
int test[5]={1,2,3,4,5};
cout<< test<<endl;         // 显示 &test[0]的地址
cout<< &test<<endl;        // 显示 整个数组地址
```

#### 3.1 指针和引用的区别

==<font color=red size=4>（重点）</font>==：**引用是 对象变量的别名，存放的也是被引用对象的地址**。<font color=red>**在底层，==引用变量==由指针按照==指针常量==的方式实现。**</font>（指针常量，即 一旦指向某一个单元就不能再指向别处）

- 引用不可以为空，但指针可以为空；因为引用是对象的别名，必须初始化。但由于引用不能为空，所以**使用指针之前必须做判空操作，而引用就不必**。
- **引用不可以改变指向（因为引用的底层实现是 指针常量）**，对一个对象"至死不渝"；但是**指针可以改变指向**，而指向其它对象。就++操作而言，对引用的操作直接反应到所指向的对象，而不是改变指向；而对指针的操作，会使指针指向下一个对象，而不是改变所指对象的内容
- **引用的大小是所指向的变量的大小**，因为引用只是一个别名而已；指针是指针本身的大小，4个字节
- **引用比指针更安全**。由于不存在空引用，并且**引用一旦被初始化**为指向一个对象，它**就不能被改变**为另一个对象的引用，因此引用很安全。**对于指针来说，它可以随时指向别的对象，并且可以不被初始化，或为NULL，所以不安全**。const 指针虽然不能改变指向，但仍然存在空指针，并且有可能产生野指针（即多个指针指向一块内存，free掉一个指针之后，别的指针就成了野指针）。



#### C++ 多态为什么只能通过指针和引用实现？

在c++的多态中，如果<font color=blue>一个基类的虚函数被派生类重写</font>，那么<font color=blue>把基类的指针指向派生类</font>，就能够通过基类调用被派生类重写的这个虚函数。

<font color=red>**【指针和引用类型，只要求基地址和指针所指对象的内存大小，与对象的类型无关。相当于，把指向的内存解释成 指针或引用的类型】**</font>

而把 派生类对象直接赋值给基类对象，牵扯到对象的类型问题，无法实现多态。

#### C++为什么有指针还要引用

<font color=red>**引用，可以解决运算符重载（或者解决函数返回值不能是左值的问题）；**</font>



#### 3.2 常量指针、指针常量

```
常量指针**（指向常量的指针）**：const int* pointer=&a"告诉编译器，*pointer是常量，不能将*pointer作为左值进行操作。
```

```
指针常量（指针本身是常量）：int* const pointer=&c"告诉编译器，pointer是常量，不能作为左值进行操作，但是允许修改间接访问值，即*pointer可以修改。
```

<font color=blue>const是修饰指针，还是修饰指针指向的数据：画一条垂直穿过指针声明的星号（*），如果const出现在线的左边，指针指向的数据为常量；如果const出现在右边，指针本身为常量。而引用本身与天俱来就是常量，即不可以改变指向。</font>

#### 3.3 指针传递、引用传递

​		引用传递和指针传递是不同的，虽然它们都是在被调函数栈空间上的一个局部变量，但任何对于**引用参数**的处理都会通过一个**间接寻址**的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果**想通过指针参数传递来改变主调函数中的相关变量，那就得使用指向指针的指针，或者指针引用。**

引用，是间接寻址

## 4、大小端问题

<font color=red>**大端法**</font>从高位到低位存储，<font color=red>**小端法**</font>从低位到高位存储。

比如某个 int 型整数的值为 0x01234567，存储在 0x100~0x103 的内存地址上。大端法和小端法的字节顺序如下所示：

<img src="https://imageslr.com/media/15978352436370.jpg" alt="-w500" style="zoom:67%;" />

注意，大端法、小端法存储的基本单位是**字节**，即一次存储 8 位。

<font size=5>**一道面试真题：**</font>

判断以下程序在 32 位机器上的输出：

```
int main() {
  int a = 0x1234;
  char *p = (char *)&a;
  printf("%02x\n", *p);
  printf("%02x\n", *(p + 1));
  printf("%02x\n", *(p + 2));
  return 0;
}
```

<font color=purple size=4>解析：</font>

如果机器是**大端法**，那么变量 `a` 在内存中地址从低到高依次为：`00 00 12 34`，共 4 个字节；

反之，如果机器是**小端法**，那么变量 `a` 在内存中地址从低到高依次为：`34 12 00 00`。

指针 `p` 始终指向 `a` 在内存中的**最低位**，这是因为取地址运算符返回的也是变量的字节的**最小地址**。在大端法机器中，`p` 指向 `00`；在小端法机器中，`p` 指向 `34`。对 `char*` 指针加 1，相当于令其所指的地址增加**一字节**。

因此，在小端机器上，上述程序的输出为：

```
34
12
00
```

在大端机器上，程序的输出为：

```
00
00
12
```



## 5、==<font color=VioletRed>内存泄漏检测、定位</font>==

<font color=red>**（绝对好文）**</font>https://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html）

内存泄漏情形

（1） 堆内存泄漏（Heap leak）：堆内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak. 这是最常见的内存泄露。

（2）系统资源泄露（Resource Leak）：主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。

（3）栈溢出：<font color=red>什么情况会出现栈溢出？</font>最常见的就是**递归**。每次递归就相当于调用一个函数，**函数每次被调用时都会将局部数据（在函数内部定义的变量、参数、数组、对象等）放入栈中**。在函数内部定义超大数组也会导致栈溢出，例如定义一个 1024 * 1024 的 int 类型的二维数组，就需要 4M 的内存，这在 VS/VC 下就会发生栈溢出。

栈内存的大小和编译器有关，编译器会为栈内存指定一个最大值；



### 5.1 ==检测是否存在内存泄漏==：（Windows上）

**在 main函数最后一行，加上一句 <font color=VioletRed>_CrtDumpMemoryLeaks( )</font>。显示内存信息**

{ 453 } **normal block** at 0x02432CA8，868 bytes long 

被{ }包围的453就是我们需要的内存泄漏定位值；

**在 main 函数第一行加上，<font color=VioletRed>_CtrSetBreakAlloc(453)</font>，在申请453这块内存的位置中断。再调试程序，查看堆栈**

<font color=VioletRed>**加上头文件 #include<crtdbg.h>**</font>

<font color=red>**注意**</font>：并不是所有的 normal block 就一定有内存泄漏。全局变量在main函数退出后才释放内存。

完整代码如下：

```
#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#include <crtdbg.h>
 
#include <iostream>
using namespace std;
 
void GetMemory(char *p, int num)
{
    p = (char*)malloc(sizeof(char) * num);
}
 
int main(int argc,char** argv)
{
    char *str = NULL;
    GetMemory(str, 100);
    cout<<"Memory leak test!"<<endl;
    _CrtDumpMemoryLeaks();
    return 0;
}
```

![image-20210530155103530](https://i.loli.net/2021/05/30/Lq4udSwKDJvHVMT.png)

<font color=red>**注意：**</font>如果程序<font color=VioletRed>总是在同一位置退出</font>，调用 <font color=VioletRed>_CrtDumpMemoryLeaks</font>将非常容易。 **如果程序从多个位置退出**，则无需在每个可能退出的位置放置对 CrtDumpMemoryLeaks 的调用，而**可以在程序开始处包含以下调用**：

```
_CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );
```



### 5.2 定位具体的内存泄漏地方

通过上面的方法，我们**几乎可以定位到是哪个地方调用内存分配函数  malloc 和 new 等**，如上例中的GetMemory函数中，即第10行！但是不能定位到，在哪个地方调用GetMemory()导致的内存泄漏。

<font color=VioletRed>**定位内存泄漏**</font>的另一种技术涉及在关键点对应用程序的<font color=VioletRed>**内存状态快照**</font>。 CRT 库提供一种结构类型 **_CrtMemState**，您可用它存储内存状态的快照：

可以这样来定位确切的调用GetMemory的地方：

```
#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#include <crtdbg.h>
 
#include <iostream>
using namespace std;
 
_CrtMemState s1, s2, s3;    // 
 
void GetMemory(char *p, int num)
{
    p = (char*)malloc(sizeof(char) * num);
}
 
int main(int argc,char** argv)
{
    _CrtMemCheckpoint( &s1 );   // 内存状态快照 s1
    char *str = NULL;
    GetMemory(str, 100);       // 内存操作相关的函数
    _CrtMemCheckpoint( &s2 );  // s2
    if ( _CrtMemDifference( &s3, &s1, &s2) )   // 计算内存分配函数调用前后的区别
        _CrtMemDumpStatistics( &s3 );
    cout<<"Memory leak test!"<<endl;
    _CrtDumpMemoryLeaks();
    return 0;
}
```

![image-20210530161421244](https://i.loli.net/2021/05/30/cx5sh46pdWySu8A.png)



**==Linux 上==**

1. <font size=4>**Valgrind**</font>：可以检查程序运行时的内存泄漏问题。
2. **使用 mtrace，协助定位内存泄漏**。编译： gcc -g -DDEBUG test.c  (gcc 的 -g  可执行程序包含调试信息，-o 指定输出文件名，-c 只编译不链接)

- 在 编译可执行的时候，**给 g++ 加参数 -g**，g++ -g 
- **允许系统生成 core dump file**；在 /etc/profile 文件中加入 ulimit -c unlimited（因为在 Linux中默认的Core文件大小设置为零，也就是不生成 Core Dump 文件）
- **gdb 带 core 文件运行可执行程序**   gdb ./aout core.file

gdb 调试core 文件的一些常用命令：

查看案发现场情况，函数调用关系   <font color=red>**(gdb) bt     // 列出程序崩溃时的堆栈信息**</font>

 <font color=red>**(gdb) info args     // 打印当前函数的参数以及其值**</font>

 <font color=red>**(gdb) info local     // 打印所有的局部变量**</font>

GDB 调试命令指南 https://blog.csdn.net/qq_26399665/article/details/81165684



## 6、内存分配

### 6.1 C 中的malloc 和 C++中的new  的区别

malloc、new 会在 **堆区** 开辟一块地址。

1. new、delete 是操作符，可以重载。而 malloc、free 是c 语言的库函数。
2. <font color=red> **malloc 的返回类型是 void*，而 new 返回的指针类型严格与对象匹配**</font>
3. <font color=#ff00000>new / delete 的底层调用了 malloc / free</font>
4. malloc/free 只能动态分配内存空间/ 释放。而 <font color=#ff00000>**new**/delete  **开辟完内存**，还能进行初始化操作（会**触发构造函数**），在释放内存之间，析构指针所指向的对象（析构函数）。</font>

### 6.2 malloc 内存管理（brk,mmap）

<img src="../AppData/Roaming/Typora/typora-user-images/image-20210531195909032.png" alt="image-20210531195909032" style="zoom:50%;" />

#### 6.2.1 动态内存分配的系统调用：sbrk

```
int brk(void *addr);
void *sbrk(intptr_t inc);
```

`brk` 用于返回堆的顶部地址；`sbrk` 用于扩展堆，通过参数 `inc` 指定要增加的大小，如果扩展成功，返回 `brk` 的旧值。如果 `increment` 为零，返回 `brk` 的当前值。

我们不会直接通过 `brk` 或 `sbrk` 来分配堆内存，而是先通过 `sbrk` 扩展堆，将这部分空闲内存空间作为**缓冲池**，然后通过 `malloc` / `free` 管理缓冲池中的内存。这是一种**池化思想**，能够避免频繁的系统调用，提高程序性能。

#### 6.2.2 malloc / free 实现思路

(深入理解计算机系统)

`malloc` 使用**空闲链表**组织堆中的空闲区块，空闲链表有时也用双向链表实现。每个空闲区块都有一个相同的**首部**，称为“内存控制块” `mem_control_block`，其中<font color=red>记录了空闲区块的元信息</font>，比如指向下一个分配块的指针、**当前分配块的长度**、或者当前区块是否已经被分配出去。这个首部对于程序是不可见的，**`malloc` 返回的是紧跟在首部后面的地址，即可用空间的起始地址**。

<img src="https://i.loli.net/2021/05/31/ZtJ5NcpTCBx4Ps6.png" alt="image-20210531200213059" style="zoom: 70%;" />

`malloc` 所实际使用的内存匹配算法有很多，执行时间和内存消耗各有不同。到底使用哪个匹配算法，取决于实现。常见的内存匹配算法有：

- 最佳适应法
- 最差适应法
- 首次适应法
- 下一个适应法

`free` 会将区块重新插入到空闲链表中。<font color=red>`free` 只接受一个指针，却可以释放恰当大小的内存，这是因为在分配的区域的首部保存了该区域的大小。</font>

<font size=4>**总结：**</font>

`malloc` 分配的函数应该是字对齐的。在 32 位模式中，malloc 返回的块总是 8 的倍数。在 64 位模式中，该地址总是 16 的倍数。最简单的方式是先让堆的起始位置字对齐，然后始终分配字大小倍数的内存。



### 6.3 delete、delete[ ] 的区别

delete 和 free( ) 的区别在于是否会调用析构函数，而 delete 和 delete [ ] 的本质区别在于 会***调用几次析构函数***。

**delete** 释放 一个动态数组的时候，虽然<u>整个数组的内存会被释放掉</u>，但是**只会调用第一个元素 析构函数**。而 **delete [ ]** <u>不仅释放整个数组内存</u>，还<u>调用每个元素的析构函数</u>。

​       **总结**：<u>对于内存的释放，<font color=#ff00000>**由于申请时记录了其大小**</font>，因此无论使用 delete 还是 delete[  ] 都能将内存空间完整释放。<font color=#ff00000>**本质区别在于 析构函数的调用次数**</font></u>。万一析构函数需要释放系统资源，而delete 仅仅释放了数组申请的内存空间，系统资源一直处于占用状态，会造成资源浪费。

###   6.4 C++ 内存分配方式： 堆，栈、全局/静态存储区、.rodata、.text (代码区)

博客地址：https://blog.csdn.net/qq_43152052/article/details/98889139

**==静态存储区：==**存储 全局变量 和 静态变量。作用域：**全局静态变量在声明它的文件之外是不可见的**。准确地讲从定义之处开始到文件结尾。 在C++中，已经不再严格区分bss和data了，它们共享一块内存区域，**静态存储区包括  .bbs段 和  .data段。**

**==（rodata段 ）常量区==**：存放的是只读数据，比如字符串常量，全局const变量 和 #define定义的常量。

==**栈区 stack(线性结构)**==：**存储 函数参数、局部变量、函数的返回地址等**。函数执行结束时，自动释放<u>栈内存分配运算内置于处理器指令集中</u>，效率很高，但是分配内存容量有限。

栈向 低地址方向 增长。栈指针 %esp 执行栈顶元素；分配内存时，将 栈指针 减小；释放内存时，增加 栈指针。

==**堆区**（**动态分配内存，链式**）：==程序在运行的时候 ，**用 new 申请任意大小的内存**，**程序员**自己负责在何时用 **delete 释放内存**。如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，另外频繁地分配和释放不同大小的堆空间将会产生**堆内碎块**。

**为什么频繁分配内存，会造成内存碎片？**



#### 为什么要区别堆、栈

- 堆 与 栈的分离，使得堆中的内容可以被多个栈共享（多个线程访问同一个对象）；
- 栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分，而栈只能向上增长。堆可以动态增长。

<font color=red>**内存本身是在堆中开辟的，而指向内存的指针存储在栈中。**</font>（一般为 1G-4G)

```
int a = 0; //全局初始化区 (在.data中)
char *p1; //全局未初始化区 (在 .bss中)
void main()
{
	int b; //栈
    char s[] = "abc"; //栈
    char *p2; //栈
    char *p3 = "123456"; //123456{post.content}在常量区，p3在栈上
    static int c = 0; //全局（静态）初始化区
    p1 = (char *)malloc(10); //分配得来的 10字节的区域在堆区
    p2 = (char *)malloc(20); //分配得来的 20字节的区域在堆区
    strcpy(p1, "123456");
    //123456{post.content}放在常量区，编译器可能会将它与p3所指向的"123456"优化成一块
}
```

```
void f()
{ 
    int* p=new int[5];    // 在栈内存中存放了一个指向一块堆内存的指针p。程序会先确定在堆中分配内存的大小，然后调用operator new分配内存，然后返回这块内存的首地址，放入栈中。
}
```

<img src="https://img-blog.csdnimg.cn/20210111232607924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zOTI3MzYyNg==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:70%;" />



### 6.5  ==对.bss段的理解==（放未初始化或初始化为0的全局变量，不占磁盘空间）

因为 .bss 段存储的是 未初始化的全局变量，所以不为该段的数据分配空间，<font color=purple>只是  记录数据所需空间的大小。</font>

​	在采用**段式内存管理的架构**中，==.bss 段通常是指用来存放程序中**未初始化的全局变量**的一块内存区域；==一般在初始化时bss 段部分将会清零。**bss段属于静态内存分配，即程序一开始就将其清零了**。<font color=red>**被初始化为0的静态变量也会被放入.bss段.**</font>

 比如，在C语言之类的程序编译完成之后，已初始化的全局变量保存在.data 段中，未初始化的全局变量保存在.bss 段中。text 和 data段都在可执行文件中，由系统从可执行文件中加载；而**bss段不在可执行文件中（因此不占用可执行文件的位置，而存储在段表中），由系统初始化。只记录数据所需空间的大小；**

#### 6.5.1 什么是静态分配？

1. 静态分配发生在程序**编译和链接**的时候。动态分配则发生在程序**调入和执行**的时候。

2. **全局变量和静态变量分配在静态数据区，本地变量分配在动态数据区**（定义在函数内部的变量就是本地变量）；**进程的每个线程都有私有的“栈”，所以每个线程虽然代码一样，但本地变量的数据都是互不干扰**。

   

### 6.6 STL 的 Allocator 分配器 工作原理

<img src="https://img-blog.csdnimg.cn/20200330095951753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fhcm9uX00=,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;" />

1. SGI 的 第一级分配器： _malloc_alloc_template，以 malloc()、free()、realloc() 执行实际的 内存配置、释放、重配置操作，并实现类似 c++ new handler 机制 (一旦malloc 无法完成任务，在丢出 std::bad_alloc 异常状态之前，会先调用有客户端指定的处理例程。)

2. 第二级分配器：_default_alloc_template。

   <u>如果区块够大 **>128 bytes**，就**用第一级**配置器处理。</u>当区块<128 bytes，则以内存池(memory pool)管理，此方法又称为次层配置。每次配置一大块内存，并维护对应的自由链表(free-list)。为了方便管理，**二级配置器会主动将任何小额区块内存需求量上调至8的倍数**（例如客户端要求30 bytes，就自动调整为32 bytes）并**维护16个free-list**，各自管理大小分别为8,16,24。。。128bytes 的小额区块。**重新填充free-list的函数[refill()](https://github.com/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_alloc.h#L537)**

   - <u>若free-list中没有可用区块时</u>，会调用**chunk_alloc 从内存池**中申请空间重新填充free-list。缺省申请20个新节点(新区块)，如果内存池空间不足，获得的节点数可能小于20。

   - **[chunk_alloc()](https://github.com/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_alloc.h#L465)函数从内存池申请空间，根据 end_free  — start_free  判断内存池中剩余的空间**

     - 如果剩余空间充足

       ​        直接调出20个区块返回给free-list

     - 如果剩余空间不足以提供20个区块，但足够供应至少1个区块

       ​		拨出这不足20个区块的空间

     - 如果剩余空间连一个区块都无法供应 (内存池不足)

       - 利用malloc()从heap中分配内存（大小为需求量的2倍，加上一个随着分配次数增加而越来越大的附加量），为内存池注入新的可用空间。
       - 如果malloc()获取失败，chunk_alloc()就四处寻找有无”尚有未用且区块足够大“的free-list。找到了就挖出一块交出。
       - 如果上一步仍未成功，那么就调用第一级分配器，第一级分配器有out-of-memory处理机制，或许有机会释放其它的内存拿来此处使用。如果可以，就成功，否则抛出bad_alloc异常。
       
       
     
   - <font size=4>关于 free_list 自由链表 自由在哪里？</font>
   
     - ```
       // free_list 的结构体定义
       union obj{
       	union obj* free_list_link;
       	char client_data[1];     // the client sees this
       }
       ```
   
       （a）共用体是一种特殊的类，也是一种构造类型的数据结构。
   
       （b）<font color=blue size=4>共用体表示几个变量共用一个内存位置，在不同的时间保存不同的数据类型和不同长度的变量。</font>（重点，精髓所在！！）
   
       （c）<font size=4>所有的共用体成员共用一个空间，并且同一时间只能储存其中一个成员变量的值。</font>
   
     <font color=blue size=4>总结：以共用体串联起来共享内存形成了 free_list 的实质组成。</font>
     
     

## 7、C 和 C++的类型安全

https://blog.csdn.net/a3192048/article/details/82499164

<font size=4>类型安全的代码不会试图访问自己没被授权的内存区域。</font>

- **C的类型安全**
  - C 只在局部上下文中表现出类型安全，比如试图从一种结构体的指针转换成另一种结构体的指针时，编译器将会报告错误，除非使用显式类型转换。
  - **malloc 是 C 中进行内存分配的函数，它的返回类型是void*，即空类型指针。**
- **C++的类型安全**
  - <font color=blue>**C++提供了一些新的机制保障类型安全：**</font>
    - 操作符**new返回的指针类型严格与对象匹配**，而不是void*
    - C 中很多以  void*  为参数的函数  可以改写为  C++ 模板函数，而**模板是支持类型检查的**；
    - C++提供了**dynamic_cast**关键字，使得转换过程更加安全，因为dynamic_cast  比  static_cast  涉及更多具体的类型检查。

想保证程序的类型安全性，**应尽量避免使用空类型指针void*，尽量不对两种类型指针做强制转换。**

### 7.1 <font color=purple>C++ 强制类型转换</font>

- <font color=blue size=5>**const_cast（常量指针 转换为 非常量指针）**</font>

```
const_cast<type_id> (expression)
```

​	<font color=blue>**常量指针被转化成非常量的指针，并且仍然指向原来的对象；**</font>

​	const_cast一般用于修改底指针。如const char *p形式；

- <font color=blue size=5>**static_cast**</font>

  **没有运行时类型检查来保证转换的安全性。**

  <font color=blue>**进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；**</font>

  进行**下行转换**（**把基类指针或引用转换成派生类表示**）时，由于没有动态类型检查，所以是**不安全的**；

- <font color=blue size=5>**dynamic_cast**</font>

  **有类型检查，基类向派生类转换比较安全，**但是派生类向基类转换则不太安全；

  dynamic_cast运算符**可以在执行期决定真正的类型**，也就是说expression必须是多态类型。

## 8、vector底层

https://www.cnblogs.com/yocichen/p/10574819.html

==**<font color=red size=4>vector 的 push_back 的时间复杂度为 O(1)，常数</font>**（均摊分析）==

### 8.1 实现原理

**<font color=#FF0000>vector是封装了动态数组的顺序容器</font>**。使用**三个指针 指向连续空间，start，finish，end_of_storage**；不过与动态数组不同的是，**vector可以根据需要自动扩大容器的大小**。具体策略是  <u>每次**容量不够**用时**重新申请一块大小  为原来容量两倍的  内存**，将原容器的元素**拷贝**至新容器，并释放原空间，返回新空间的指针</u>。

因此，对 vector 的任何操作，一旦引起 **空间重新配置**，指向 **原vector的所有迭代器** 就都**失效**。（内部 使用 allocator 空间配置方式）

在原来空间不够存储新值时，每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。如果在程序中频繁进行这种操作，还是比较消耗性能的。

vector 的成员函数 emplace_back( ) 和 push_back( ) 一样，将一个元素 插入容器尾部。区别在于：使用 **push_back 函数 需要调用 拷贝构造函数 或者 移动构造函数，而 emplace_back 插入的元素，原地构造（即只需要 构造函数），不需要 拷贝构造，效率更高。**

**<font color=#FF0000>vector 扩容在 VS 下是 1.5倍，在 GCC 下是 2倍。</font>**

**两倍扩容的原因：**

​		采用 <font size=4>**==成倍扩容，可以保持 常数的时间复杂度==**</font>，而**增加指定大小的容量**，只能**达到O(n)的时间复杂度**。<font size=4>==最好的增长因子在 <1,2> 之间==</font>

### 8.2 如何避免vector 的扩容？reserve

​	<font color=blue>**reserve（）避免多次不必要的扩容**</font>；reserve的作用是更改vector的容量（capacity），使vector至少可以容纳n个元素。

​	如果一个vector使用默认的capacity，那么在push_back操作的时候，会根据添加元素的数量，**动态的自动分配空间，2^n递增**；
**如果声明vector的时候，**显式的使用capacity(size_type n)来**指定vector的容量**，那么**在push_back的过程中（元素数量不超过n），vector不会自动分配空间。**

```
int main(){
	uint16_t sz = 0;
	vector<int> vecIntA;
	sz = vecIntA.capacity();
	//声明vector后未使用reserve，直接进行push_back操作 
	cout << "Making vecIntA growing:" << endl;
	growPushBack(vecIntA, sz);
	
	cout << "\n========separator========\n" << endl;
	
	vector<int> vecIntB;
	sz = vecIntB.capacity();
	//声明vecIntB后用reserve来执行其容量为100 
	vecIntB.reserve(100); 

```

### 8.3 vector.clear ( )

clear( ) 只是 清空vector 的元素，而 vector 申请到的内存空间不会被释放掉。**可以通过 swap 一个空的vector 来释放内存**

```
vector(Vec).swap(Vec);   //将Vec的内存空洞清除；

vector().swap(Vec);    // 清空Vec的内存；
```



### 8.4 vector、list 区别（重点）

**list** 是由**双向链表**实现的，<font color=red size=4> **list 内存空间是不连续（内存不连续，会导致 catch 命中率降低）**</font>的。只能通过指针访问数据，但<font color=red size=4>由于链表的特点，能高效地进行插入和删除。</font>

而<font color=red size=4>  **vector，连续内存空间(增加 catch 命中率)**</font>，所以插入、删除操作 会 造成内存块的拷贝。



## 9、Heap  Priority queue（优先队列）

1、以 vector 作为底层容器。max-heap 的 最大值在根节点，并总是位于底层vector 的头部。min-heap 则相反。

2、**push_heap** 算法。为了满足 *完全二叉树*   特点，**加入的 新节点** 总是 插入 在 **vector 的 end( )**，然后再 上溯调整 树结构。

3、**pop_heap 算法**。将根节点设置为 vector 的尾端节点。然后再下溯调整树结构。

3、sort_heap：不断调用 pop_heap 算法，不断将最大值根节点设置为 vector 的尾端节点。最后 即为 递增序列。

**Set、Map 的 底层机制是 红黑树。搜索时间为  O(N log N)。**



## 10、<font color=VioletRed>unordered_map、map</font>

 unordered_map<font color=VioletRed> 内部采用 hashtable </font>的数据结构存储，每个特定的 key 会通过特定的哈希运算映射到一个特定的位置。

一般来说，**hashtable 是可能存在冲突的**，即不同的key值经过哈希运算之后得到相同的结果。**解决方法是**：**在每个位置放一个桶，**用于存放映射到此位置的元素， <font color=red>**当桶内数据量在8以内使用链表来实现桶**</font>，当数据量<font color=red>**大于8 则自动转换为红黑树结构**</font> 也就是有序map的实现结构。

#### 10.1 线程不安全：

如果多个线程同时访问一个哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。

1. 假如 A线程 和 B线程  同时对同一个数组位置调用 put ，两个线程会同时得到现在的头结点，然后A写入新的头结点之后，B也写入新的头结点，那B的写入操作就会覆盖A的写入操作造成A的写入操作丢失。（发生了 数据覆盖）
2. **当并发执行扩容操作时会造成环形链和数据丢失的情况。**



### map 可以通过迭代器修改 key 值吗？不能，迭代器只能 read-only-member (大疆)

http://t.zoukankan.com/yunlambert-p-13620363.html

<font size=4 color=red>C++17中的key值修改：</font>

​	**修改key的策略是通过容器携带的接口**，而不是通过迭代器进行修改。

c++17中给关联容器提供了一个方法：`extract`，这提供了保存容器元素的节点：

**在C++17之前，做法就是erase key所在的元素然后再更新后插入**，但是这样的做法非常的低效而且不直接。



### 10.2 哈希冲突相关？

<font size=4 color=red>装载因子的作用是什么？？ 百度二面</font>

1. **开放地址法**

   线性探测；二次探测；随机探测

2. **拉链法**（哈希+链表）

##### 如果使用hash进行分布式存储有什么弊端？如何解决？

<font color=red>（可扩展性不强，例如增加节点和节点宕机的情况）；一致性哈希</font>

##### 一致性hash会出现什么问题？如何解决？

<font color=red>（数据倾斜问题）（虚拟节点）</font>



## 12、==智能指针==

<font size=4 color=VioletRed>**解决什么问题？（方便管理堆内存）**</font>

 	C++11中引入智能指针，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。
 	但是，同时智能指针也会存在 内存泄漏。指针相互引用，导致计数器!=0,无法释放内存。

**<font color=blue>shared_ptr 允许多个指针指向同一个对象。(引用计数器。)</font>**

unique_ptr “独占”所指向的对象。

**一旦一个 shared_ptr 的 计数器 0**，它就会**自动释放自己所管理的对象**。**shared_ptr 的析构函数 会递减 它所指向的对象的引用计数**。

shared_ptr<int> p2 ( new int (42) );  // 接受指针参数的**智能指针构造函数是 explicit**  的。因此**不能隐式转换**。

```
	int *num = new int(23);
    std::shared_ptr<int> p1(num);
    std::shared_ptr<int> p4 = new int(1); //error 注意，不能将一个原始指针直接赋值给一个智能指针，一个是类，一个是指针。
    std::shared_ptr<int> p4(new int(5));  // 正确的使用方式
    
    std::shared_ptr<int> p2(p1);  // 正确使用方法
    std::shared_ptr<int> p3(num); // 不推荐 不要用一个原始指针初始化多个shared_ptr

    std::cout << "p1 Reference = " << p1.use_count() << std::endl; // 输出 2
    std::cout << "p2 Reference = " << p2.use_count() << std::endl; // 2
    std::cout << "p3 Reference = " << p3.use_count() << std::endl; // 1

```



### 12.1 shared_ptr 的线程安全问题

<font color=VioletRed>**智能指针 包括 数据指针+引用计数指针**</font>，这两个操作不是一个指令就可以完成的。

<img src="../AppData/Roaming/Typora/typora-user-images/image-20210310101653958.png" alt="image-20210310101653958" style="zoom:67%;" />

<font size=4>**shared_ptr的定义如下：**</font>

```
template<class _Ty>
class shared_ptr : public _Ptr_base<_Ty>
```

 **shared_ptr  从基类  _Ptr_base   继承了如下成员变量：**

```
template<class _Ty>
class _Ptr_base
{
private:
    element_type * _Ptr  { nullptr };      //指向资源
    _Ref_count_base * _Rep { nullptr };   //指向资源引用计数
}
```

 **_Ref_count_base的定义如下：**

```
class __declspec(novtable) _Ref_count_base
{	// common code for reference counting
private:
	_Atomic_counter_t _Uses;   //记录了引用资源的shared_ptr的个数
	_Atomic_counter_t _Weaks;  //记录了weak_ptr的个数 （相当于，资源观察者的个数）
}
```

<font color=blue>**shared_ptr的构造函数中会开辟新的引用计数的资源**。</font>

<font color=blue>  **shared_ptr的拷贝构造函数没有开辟新的引用计数的资源，只是引用计数加1。**</font>

正确代码：

```
#include <iostream>
#include <memory>
using namespace std;
int main()
{
    // 裸指针指向堆上的对象
    int *p = new int;       
    shared_ptr<int> ptr1(p);
    shared_ptr<int> ptr2(ptr1);
    //两次打印都是2，析构一次，正确
    cout << "use_count = " <<  ptr1.use_count() << endl;
    cout << "use_count = " << ptr2.use_count() << endl;
    getchar();
    return 0;
}
```

 原因：ptr1(p)  调用构造函数，ptr2(ptr1) 调用拷贝构造函数（没有开辟新的引用计数的资源，只是引用计数加1）。析构函数会被调用一次，所以程序正确。

- **<font color=VioletRed>同一个shared_ptr 被多个线程读，是线程安全的（多线程获取 计数器值，安全）；</font>**
- **<font color=VioletRed>同一个 shared_ptr 被多个线程写，是 线程不安全的；</font>（引用计数 -1，即为 写操作）**
- **共享引用计数的不同** shared_ptr 被多个线程写，是**线程安全**的。



**<font color=VioletRed>造成 智能指针线程不安全的原因：</font>**

​		<font size=4 color=red>shared_ptr 在对计数器进行修改的时候需要加锁实现线程安全，因为如果有两个指针同时引用一个对象时，得到的计数值可能为2，正确应该是3。</font>

<font color=red size=4>**weak_ptr** 弱指针</font>。**不能访问对象。<font color=red>只能观测shared_ptr的引用计数，防止出现死锁。</font> <font color=purple>因此，将 weak_ptr 绑定到一个 shared_ptr ，不会改变 shared_ptr 的引用计数</font>。 **它不能访问对象。（在 shared_ptr 中出现死锁的原因是，指针之间的相互指向，形成环，引用计数不为0，无法释放内存，造成内存泄漏，而 weak_ptr 不用改变引用计数，可以防止 死锁）

**<font color=red size=4> unique_ptr：</font>** **为动态申请的资源，提供异常保护机制。**



<font color=blue size=4>**auto_ptr**</font>：（只在本作用域内有效，不能被作用域外的对象拷贝），对象独占性。

​	主要是<font size=4>**为了解决“有异常抛出时发生内存泄漏”的问题**；抛出异常，将导致指针p   所指向的空间得不到释放而导致内存泄漏；</font> 由于<font size=4>**auto_ptr 对象析构时会删除它所拥有的指针**，所以使用时**避免多个auto_ptr对象管理同一个指针**；**auto_ptr的对象所有权是独占性的！**</font>

<font color=blue size=4>**shared_ptr**</font>：解决  **auto_ptr**  在对象所有权上的局限性（auto_ptr是独占的），在使用**引用计数的机制**上提供了可以共享所有权的智能指针。

### ==12.2 shared_ptr的引用计数原理==

【	定义一个具体类**（U_Ptr）来封装引用计数和指针**。在创建智能指针类之前，**这个类的所有成员皆为私有类型**，因为它不被普通用户所使用。为了只为智能指针使用，还需要**把智能指针类声明为该类的友元**。类中包含含**两个数据成员：计数count与之前HasPtr类中的指针（ int *ptr;）**。】

​	<font color=blue>**指向相同资源的所有 shared_ptr 共享“引用计数管理区域“**</font>，并**采用原子操作保证该区域中的引用计数值被互斥地访问**。“引用计数管理区域”是指通过 new 创建的 sp_counted_impl_p<D> 或 sp_counted_impl_pd<D> 对象，**在创建成功后立即由其基类指针指向它，而该基类指针被 shared_ptr 间接持有。**

**M 指的是 sp_counted_impl_p<D> 或 sp_counted_impl_pd<D>**

<img src="../AppData/Roaming/Typora/typora-user-images/image-20210317121119120.png" alt="image-20210317121119120" style="zoom:67%;" />

<font size=4 color=red>注意看图：</font>**shared_ptr 模板类有一个shared_count类型的成员** _ M_refcount来处理引用计数的问题。**__shared_count也是一个模板类，它的内部有一个指向Sp_counted_base_impl类型的指针 _ M_pi**。<font size=4 color=red>所有引用同一个对象的shared_ptr都共用一个_M_pi指针。</font>



## 13、C++11 新特性

<font color=blue size=4>**定义了移动构造函数之后，还会生成拷贝构造函数吗？（不会）(大疆)**</font>

https://blog.csdn.net/huatian5/article/details/82349313

- 编译器会**自动生成拷贝构造函数**   和   **移动构造函数**。
- <font color=blue size=4>有拷贝构造函数还会默认生成移动构造函数吗？(不会)</font>



**Lambda 表达式**：匿名函数，

```
[ caputrue ] ( params ) -> ret { body; };
```

capture是捕获列表；params 是参数表，ret 返回值类型；capture 控制 lambda表达式能够访问到的 外部变量，以及访问的方式（引用/ 值 传递）。 ==**lambda 表达式返回的结果 是一个 右值**==。右值无法被赋值，但可以用  拷贝构造函数，初始化一个 lambda对象。每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（闭包类型）；闭包的强大之处在于，通过传值或者 引用的方法捕捉其封装作用域内的变量。

<font size=4 color=red>为什么要用 lambda表达式？</font>

- 因为**非匿名函数在定义时**，就已经创建函数对象和作用域对象；所以，**即使未调用，也占用内存空间**；

- 匿名函数，仅在调用时，才临时创建函数对象和作用域链对象；调用完，立即释放，所以匿名函数比非匿名函数更节省内存空间

```
int ret = [](int x, int y) {return x + y;}(1, 2);

std::sort(arr.begin(),arr.end(),[](int x,int y){
return x>y;
})
```



==加入了 **nullptr**，**解决NULL在C++中的二义性**==：

在 C 中，用NULL代表空指针， **#define NULL((void*  )0)**；在 C中允许发生隐式转换，把 void* 指针转换成 相应的指针;

而 C++中，**void * 是无法进行隐式转换的**，**在C++中,NULL实际上就是0**，当函数重载时，会出现二义性。C++11中，引入 nullptr 来代替空指针。



## 14、右值 及 右值引用 (&&) 模板类型推理 

#### <font color=purple>为什么要有右值引用（重点）</font>

- <font color=red>**右值引用解决模板函数中如何按照参数的实际类型进行转发（完美转发**）</font>

  从 左值引用函数参数推断类型：

  当模板参数为一个左值引用时，传递给该模板参数的实参必须为一个左值；如：

  ```
  template<typename T> void f1(T &);
  int i = 1;  f1(i);              // i 是一个 int，模板参数类型 T 是int
  const int ci = 2; f1(ci);       // ci 是一个 const int；T 是 const int;
  f1(5);                          // 错误，左值引用不能绑定到一个右值。
  ```

  <font color=red>**从 右值引用函数参数推断类型：**</font>

  ```
  template<typename T> void f3(T &&);
  f3(10);                        // 实参是一个 int 类型的右值; 模板参 数 T 是 int
  f3(i);                        // T 是 int&, 模板参数 T是 int& &&
  ```

  <font color=red>引用的引用会被折叠：</font>

  <font color=purple>X& &，X&  &&,   X&& & 都被折叠成 X&；</font>

  X&& && 被折叠成 X&&

  - <font color=red size=4>**移动语义**</font>

  比如 **vector 的增长**，没有移动语义之前是复制并删除，其实只要移动就好了。

  再比如 **unique_ptr** 放入容器，**没有移动语义之前**由于vector增长需要复制对象，像**unique_ptr 这种不可复制对象不能存入容器**。

  <font color=purple size=4>左值引用：</font>

​        左值引用，最直接的原因是：方便运算符重载。

```
A operator +(const A *a, const A *_a); &a+&b;  // 没有左值引用
A operator +(consta A &a, const A &_a);  a+b;  // 左值引用
```

**<font color=purple>引用由于要初始化，并且不能更改绑定对象，解决了 空指针和野指针的问题</font>；但是，<font color=red>也有能使用指针不能使用引用的场合：比如传递函数指针。</font>**



## 15、 浅拷贝、深拷贝

==浅拷贝==： 对象的数据成员之间的简单赋值。

当数据成员中有指针时，**采用浅拷贝**，则 **两个指针 指向同一个地址**。当对象结束时，会调用两次析构函数，造成 **指针悬挂现象**。

==深拷贝== ：深拷贝会**在堆内存中申请空间来存储数据。**

当拷贝对象中有对其他资源（如堆、文件、系统等）的引用时（引用可以是指针或引用）时，对象的另开辟一块新的资源，而不再对拷贝对象中有对其他资源的引用的指针或引用进行单纯的赋值。

<font color=\#9999CC>**深拷贝可以避免重复释放和写冲突。例如使用浅拷贝的对象进行释放后，对原对象的释放会导致内存泄漏或程序崩溃。**</font>

<font color=red size=4>**C++ 默认的拷贝构造函数是 浅拷贝，复制拷贝构造函数 是  深拷贝**</font>



##  16、 ==C++虚函数相关（虚函数表+虚表指针）==

博客地址：https://blog.csdn.net/lihao21/article/details/50688337

每个<font color=#FF0000> 包含了虚函数的类都包含一个虚表 </font>（ 虚表是属于类的，**<font color=#ff0000>同一个类的所有对象</font>  都使用   <font color=#ff0000>同一个虚表</font>** ）

虚表可以看出是  函数指针数组，每个元素对应一个虚函数的函数指针。

虚表内的条目，即**==虚函数指针的赋值发生在编译器的编译阶段==**，也就是说<font color=#ff0000>在代码的编译阶段，虚表就可以构造出来了。</font>

每个类对象都有一个 ==**__vptr 指针来指向 虚表。**==

**把经过虚表调用虚函数的过程称为动态绑定**，其表现出来的现象称为<font color=\#9999CC>**运行时多态**</font>。动态绑定区别于传统的函数调用；**静态多态：通过函数重载实现的多态，在编译期间确定行为。**

<font color=#ff0000>**C++虚函数表是支撑C++多态的重要技术**</font>，它是C++动态绑定技术的核心。

在多继承情况下，有多少个基类 (包含虚函数的) 就有多少个虚函数表指针；父类中没有的虚函数而子类有，填入第一个虚函数表中，且用父类指针是不能调用。

### 16.1 虚表存在哪里？(全局存储区,只读数据段)

- <font color=\#9999CC>**虚函数表 由编译器在编译时生成，并存储在进程（可执行文件）的只读数据段内（.rdata）即全局数据区；**</font>



## 17、当子类对父类的虚函数进行覆盖时，子类如何调用父类函数？

在子类里面显示调用父类函数，base:: func();

```
#include<iostream>
using namespace std;
class A{
public:
    virtual void func(int i){
        cout<<"func(int i)"<<endl;
    }
};

class B:public A{
public:
    virtual void func(int i,int j){
        cout<<"func(int i,int j)"<<endl;
    }
};

int main(){
    A a;
    B b;
    a.func(2);
    b.func(2,3);
    b.A::func(2);    //  子类调用父类的方法
    system("pause");
    return 0;
}
```

##  18、基类的析构函数一般写成虚函数的原因

​		首先析构函数可以为虚函数，<font color=#ff0000>当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源</font>。

​		如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。

#### 18.1 构造函数 不可以为 虚函数：

**<font color=#ff0000>对象还没有实例化，怎么调用 虚函数表？</font>**

1. 因为==创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的==。而在构造一个对象时，**由于对象还未创建成功，编译器无法知道对象的实际类型**，是类本身还是类的派生类等等

2. ==**虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中**==；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了

   

#### 18.2 编译器如何处理虚函数表

编译器处理虚函数的方法是：
		**如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中**。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。
		**为每个类的实例添加一个虚表指针（vptr）**，虚表指针指向类的虚函数表。**实例在调用虚函数的时候，通过这个虚函数表指针找到类中的虚函数表，找到相应的函数进行调用。**

### 18.3 静态函数能为虚函数吗？常函数呢？说说你的理解

1. <font color=blue>static 成员不属于任何对象或类实例，所以即使给此函数加上 virtual 也没有意义</font>

2. 静态和非静态成员函数的最主要区别在于，**静态成员函数没有 this 指针。**

   虚函数 利用 vptr 和 vtable 来处理。<font color=#ff0000>vptr 是一个指针，在类的构造函数中创建生成，并只能用 this 指针来访问它</font>。而对于静态成员函数，**没有this 指针，无法访问 vptr**。

   **虚函数的调用关系：this ->vptr-> vtable-> virtual function**

<font color=blue>静态成员还是只能访问静态成员变量。</font>



### 纯虚函数

<font color=red>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。</font>



## 18.4 析构函数可以抛出异常吗？构造函数呢？

==**析构函数**     <font size=5>不能  </font>抛出异常==

> 如果对象在运行期间出现了异常，C++异常处理模型有责任清除那些由于出现异常导致的已经失效的对象，并释放对象原来分配的资源。析构函数已经成为处理异常的一部分

1. 如果析构函数抛出异常，则异常点之后的程序不会执行。如果析构函数在异常点之后，执行了某些操作，比如释放资源，则这些操作不会执行，**会造成内存泄漏**。
2. 通常异常发生时，C++的机制会调用析构函数 来释放资源。此时析构函数抛出异常。则前一个异常还未处理，又有新的异常，会导致程序崩溃。

==**构造函数**<font size=5>     能   </font>抛出异常==

动态创建对象要进行两个操作：分配内存和调用构造函数。若在分配内存时出错，会抛出 bad_alloc 异常；若在 调用构造函数初始化时出错，**不会造成内存泄漏**。

<font color=#ff0000>**new 运算符保证不会出现内存泄漏：**</font>

```
T *p = new T;
```

将被 编译器转换成类型下面的样子：

```
void allocate_and_construct()
{
	try{
		new (p) T;
	}
	catch(...){
		delete p;
		throw;
	}
}
```



##  19、C++中的重载和重写的区别

<font color=red>重载、重写，都是实现多态的。重载是编译时的多态，重写时运行时多态。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载（重载对返回类型没有要求）；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表。</font>

* **重载**（overload）是指**函数名相同，参数列表不同**的函数实现方法。它们的**返回值可以不同**，但返回值不可以作为区分不同重载函数的标志。
* **隐藏**：两个函数参数相同，但 基类函数不是虚函数。**和重写的区别在于   基函数是否是虚函数**
* **重写**：用于**C++多态**中。<font color=red>**子类改写父类中 virtual 方法**</font>。**函数原型相同**。



## 20、==（重要）计算类的大小==

<font color=#ff0000>**空类会占用1字节，这是为了让 对象实例相互区别。**</font>

具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样**空类实例化之后就会拥有独一无二的内存地址。**当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。

## 21、结构体内存对齐方式，为什么要进行内存对齐？

因为结构体的成员可以有不同的数据类型，所占的大小也不一样。同时，<font color=#ff0000>**CPU读取数据是按块读取的**，内存对齐使得CPU一次就可以将所需的数据读进来。 </font> https://www.cnblogs.com/clover-toeic/p/3853132.html

<font color=blue>**字节对齐的必要性：**</font>

但最常见的情况是，如果不按照平台要求对数据存放进行对齐，会带来存取效率上的损失。**比如32位的Intel处理器通过总线访问**(包括读和写)内存数据。**每个总线周期从偶地址开始访问32位内存数据，内存数据以字节为单位存放。如果一个32位的数据没有存放在4字节整除的内存地址处，那么处理器就需要2个总线周期对其进行访问**，显然访问效率下降很多。

**对齐规则：**

* 从0地址开始存储
* 除结构体的第一个成员外，<font color=purple> **其他所有的成员的地址相对于结构体地址(即它首个成员的地址)的偏移量必须为实际对齐单位或自身大小的整数倍(取两者中小的那个)**</font>
* 对齐数=编译器默认的一个对齐数 与 该成员大小的较小值。
* linux 中默认为4
* vs 中的默认值为8
  <font color=red>**结构体总大小为最大对齐数（字节边界数）的整数倍**</font>（每个成员变量除了第一个成员都有一个对齐数）

<font size=5 color=green> \#pragma pack(1)</font>，调整为 1 字节对齐边界，可以节省内存空间。否则 **编译器会按照 成员变量中最大的变量进行 字节对齐。**

<img src="https://i.loli.net/2021/10/09/lWJUQIEOuSZwgBa.png" alt="img" style="zoom:70%;" />

char a 放在结构体的起始地址;

short b占2个字节，2小于实际对齐字节8，故b的起始地址相对于a的起始地址的偏移量须为2的整数倍个字节;

int c占4个字节，4小于实际对齐字节8，故c 起始地址相对于a的起始地址的偏移量须为4的整数倍个字节；

double d占8个字节，8与实际对齐字节8相等，故d的起始地址相对于a的起始地址的偏移量须为8的整数倍个字节；

**所以nums所占空间如下:    1(a)+1(浪费的空间，由b的起始地址决定这1字节必须腾出)+2(b)+4(c)+8(d)=16个字节**

<img src="https://i.loli.net/2021/10/09/X9mzEHGO2j4i3ob.png" alt="img" style="zoom:70%;" />



### 计算类的大小

计算类大小的规律：   

1、空类、单一继承的空类、多重继承的空类所占空间大小为：1

2、<font color=red>**一个类中，虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间的**</font>；

3、因此一个对象的大小 ≥  所有非静态成员大小的总和（包括动态分配的变量...）；

4、当类中声明了虚函数（不管是1个还是多个），那么在实例化对象时，编译器会自动在对象里安插一个指针vPtr指向虚函数表VTable；

5、虚继承的情况：虚继承的实现是通过虚函数表，会同时增加一个（多重虚继承下对应多个）vfPtr指针指向虚函数表vfTable和一个vbPtr指针指向虚基表vbTable，这两者所占的空间大 小为：8（或8乘以多继承时父类的个数）；

6、在考虑以上内容所占空间的大小时，还要注意编译器下的“补齐”padding的影响，即编译器会插入多余的字节补齐；



## 22、inline关键字 

​		内联函数用于优化规模较小、频繁调用的函数。因为<font color=red>**函数频繁调用会占用很多的栈空间**</font>，进行入栈出栈操作也耗费计算资源，所以可以用  **inline关键字修饰频繁调用的小函数**。

**inline 在编译期间展开，而#define 宏定义在 预处理时展开**；<font color=#ff0000>**内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。**</font>



## const 在函数名 前面和后面的区别？

<font color=red size=4>当const在函数名前面的时候修饰的是函数返回值</font >；

<font color=purple size=4>在函数名后面表示是常成员函数，该函数不能修改对象内的任何成员，只能发生读操作，不能发生写操作</font>。修饰谁，谁就不能发生修改！

### extern “C”

​	**C++**语言**在编译的时候为了解决函数的多态**问题，会<font color=blue>**将函数名和参数联合起来生成一个中间的函数名称**</font>，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就**需要用extern “C”进行链接指定，告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。**



## ==static(隐藏性) 用法 百度2次 大疆==

最重要的特性：隐藏（当 同时编译多个文件时，**所有未加 static 的全局变量 和函数 都有 全局可见性，**<font color=#ff0000>**static 修饰的变量 仅对本文件使用**</font>）

<font color=red size=4>**全局变量：**</font>**程序的所有部分（其他文件的代码）都可以使用。全局变量不受作用域的影响。**

<font color=red size=4>**static 全局变量：**</font>**限制了其作用域， 即只在定义该变量的源文件内有效（修饰的作用域：本身的编译单元）**， **在同一源程序的其它源文件中不能使用它**。



【NOTE】<font color=purple size=4>静态成员：不管这个类创建了多少个对象，静态成员在内存中只保留一份，**静态成员用来解决同一个类中不同对象之间数据成员和函数的共享问题**。</font>

静态成员函数，属于整个类而并不属于类的某个对象。所以，**静态成员函数没有 this 指针。**

<font color=red>**静态变量在编译阶段就分配了空间**，不占用类大小</font>。

* 变量：被static修饰的变量就是静态变量，它会在程序运行过程中一直存在，会被放在**静态存储区**。==**局部静态变量**==的作用域**在函数体中**，==**全局静态变量**==的作用域在**这个文件里**。 而==**全局变量**==的作用域是整个项目，它**只需要在一个源文件中定义**就可以**作用于所有的源文件。**
* 把局部变量改变为静态变量之后是改变了它的存储方式和生命期；把全局变量改变为静态变量之后是改变了它的作用域，限制了使用范围
* 类：将类成员变量声明为static，则为**静态成员变量**，与一般的成员变量不同，**无论建立多少对象，都只有一个静态成员变量的拷贝，静态成员变量属于一个类，所有对象共享。**

<font color=#ff0000>注意和const的区别</font>  **==const强调  值不能被修改，而 static强调  唯一的拷贝，对所有类的对象都共用。==**



## ==C++函数调用的压栈过程==

**数组作为参数的函数调用方式是地址传递**，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。

<font size=5>当main函数开始调用func()函数时，编译器此时会将main函数的运行状态进行压栈，再将func()函数的返回地址、func()函数的参数从右到左、func()定义变量依次压栈；</font>

1. **将被调用函数的==各个参数从右向左逐步压入栈中==，最后压入返回地址**(call 指令的下一个指令)（**这两件事都是  调用者负责的**）

2. 被调用函数将 老的（调用函数）% ebp压入栈，此时 %esp指向它；再将 %esp的值赋值给 %ebp (mov ebp esp)。这样就保存了“调用者”函数的%ebp，并建立一个新的栈帧。   (%ebp: 基址指针；%esp：栈指针)**（在栈上分配局部变量空间）**

   

## volatile关键字的作用

volatile的本意是“**易变的**”。设计**用来修饰被不同线程访问和修改的变量**。volatile关键词影响编译器编译的结果，**用  volatile 声明的变量**表示该变量随时可能发生变化。编译器对访问该变量的代码就不再进行优化，（即**每次都从内存中读取该变量，而不是从CPU的寄存器中读取**）

**volatile：该关键字的作用是防止优化编译器把变量从内存装载到CPU寄存器上。**

可见性：<font color=#ff00000>当一个线程修改了由volatile关键字修饰的变量的值时，其它线程能够立即得知这个修改。</font>
有序性：禁止编译器关于操作volatile关键词修饰的变量的指令重排序。

**<font color=red>volatile 应用的场景：多线程对共享资源的访问的时候，避免编译器的优化而造成多线程之间的通信不匹配。</font>**



## 平衡二叉树和红黑树的区别

==**平衡二叉树 是严格的**==平衡二叉树，==要求左右子树的高度差不超过 1==。只要不满足条件，就要通过旋转保持平衡。所以 平衡二叉树 适用于 插入，删除次数少，而查找次数多的情况。

==红黑树==，每个节点 增加一个存储位表示结点的颜色。==弱平衡==二叉树。**插入最多2次旋转，删除最多3次旋转**。它可以**在O(log n)时间**内完成查找，插入和删除。

==红黑树的特性:==
（1）每个节点或者是黑色，或者是红色。
（2）<font color=#ff00000>根节点是黑色。</font>
（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
（4）<font color=#ff00000>如果一个节点是红色的，则它的子节点必须是黑色的。</font>
（5）**从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点**。[这里指到叶子节点的路径]

设置 新添加的节点为 红节点

### 为什么红黑树是好的二叉搜索树

<font size=4>一棵内部有<font color=red>**n个结点的红黑树的高度至多为2∗logn**</font>（性质4）。这保证了**<font color=red>红黑树任意操作的复杂度都是O(logn)。</font>**</font>



# （二）Linux 系统编程

**软连接**：相当于Windows 上的 **快捷方式** ，存放文件的路径名。-s 创建（**当删除文件，连接无效**）

**硬连接**：**同一个文件使用了多个别名**（有共同的 inode），用命令 link 或 ln 创建**（多个文件名，指向同一索引节点）**

### grep 命令（指定查找“xx”关键词的文件）

<font size=4 color=blue>grep -r "{关键字}"  {路径}</font>

### Diff 命令（比较两个文件的不同之处）

<font size=4 color=blue>diff -ruN a.txt b.txt > patch.txt  </font> 参数 -u 表示使用 unified 格式，-r 表示比较目录，-N 表示将不存在的文件当作空文件处理；**将 两个文件的不同之处，添加到 patch.txt中。**

### sed 读取文件的 前10-20行

<font size=4 color=blue>sed -n '10,20p' 1.txt</font>

<font size=4 color=blue>tail -n +10 1.txt | head -n 10 </font>

<font size=4 color=blue>tail -n 1000：显示最后1000行</font>

<font size=4 color=blue>tail -n +1000：从1000行开始显示，显示1000行以后的</font>
<font size=4 color=blue>head -n 1000：显示前面1000行</font>

### 文件里面去重复值（uniq 命令）

### 查看文件内容，有哪些命令

- vi      #编辑方式查看，可修改
- cat    #显示全部文件内容
- more  #分页显示文件内容
- less   #与 more 相似，更好的是可以往前翻页
- tail     #仅查看尾部，还可以指定行数
- head   #仅查看头部,还可以指定行数

### 用什么命令对一个文件的内容进行统计？(行号、单词数、字节数)

**wc 命令 - c 统计字节数 - l 统计行数 - w 统计字数。**

### 查看某个进程的情况

<font color=red size=4>strace -p pid</font>

### Linux 如何查看端口被哪个进程占用？

<font color=red size=4>lsof (list  open files) -i: 端口号</font>

## Linux 常用指令

1. **ls**：显示文件或目录； ls -l 显示文件详细信息     **stat** 查看文件的详细信息

2. **mkdir** 创建目录

3. cd  切换目录

4. **touch** 创建空文件

5. **cat** 查看文件内容

6. **pwd**  显示当前目录

7. **ps** 查看当前进程    **ps -ef| grep php  ##查看所有有关 php 的进程**；ps -aux 查看所有进程；ps -aux|grep java 查看java进程

8. Linux 管道，将一个命令的输出作为另一个命令的输入。  grep -r "close"/home/* | more，

9. **kill** ：kill **-9** 123456，**彻底杀死**进程 ；  kill  **-15** 123456 **正常终止**进程

10. <font color=red>**top：查看CPU资源占用情况**</font>

11. <font color=red>**free：用于显示 内存状态。 free  -m：以MB 为单位显示内存的使用情况。**</font>

12. **chmod** ：控制用户对文件的权限的命令  代表 **User、Group、Others 的权限**  **7:111 读、写、执行**

13. **stat 指令**：显示 文件/文件系统的详细信息。 **cat** ：文本输出命令，通常用于查看某个文件的内容。

14. ==**netstate：查看端口状态等。**==

    <font color=purple size=4>state 端口状态有哪值？</font>

    -  close 初始（无连接）状态；listening 监听状态，等待远程机器的连接请求；SYN_SEND 主动连接方发送 SYN包后，进入 SYN_SEND；SYN_RECV，主动方接收到 ACK后，进入 SYN_RECV；ESTABLISHED(建立)，完成3次握手后；
    - **FIN_WAIT_1；FIN_WAIT_2；TIME_WAIT；CLOSE_WAIT; LAST_ACK**

### find 查找文件命令

> 语法：find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \;

find 在指定的目录下查找文件，查找的方式可以根据 正则式、类型、深度、时间、权限，可以设置删除这些文件；

```
find . -name "*.c"     #将当前目录及其子目录下所有文件后缀为 .c 的文件列出来
find . -type f         #将当前目录及其子目录下的  一般文件 列出来
find . -ctime -20      # 将当前目录及其子目录下所有最近 20 天内更新过的文件列出
find . -type f  -print0   #输出的文件列表以 null 分隔
```



### 查看内存使用率

- top 命令；

<font size=4 color=red>top -p pid：查看某个进程的内存使用</font>

查看更详细的内存占比

```
cat /proc/10997/status   //  10997，为对应进程的PID
```

- free 命令；free命令可以显示Linux系统中空闲的、已用的物理内存及swap内存，及被内核使用的buffer。

  ```
  free -b // 以 Byte为单位显示内存使用情况
  free -k // 以 KB 为单位 
  .... -s  // 间隔秒数
  .... -t  // 显示内存总和列
  ```

## 文件系统

http://m.elecfans.com/article/1625158.html

文件系统有3个关键区域：超级块区域、inode区域、数据 block区域；

一个 inode 和一个文件对应，包含了文件的元数据信息；

有 两种文件类型：普通文件 和目录文件；`inode->i_mode`使用宏 S_ISREG 、S_ISDIR 判断 文件类型；

- 普通文件，存储 inode，inode 存储元数据可以索引到 block，block 存储用户数据；
- 目录文件，block 存储目录条目；`inode->i_blocks`；通过 i_blocks 能索引到 这些 block，存储的是一个个目录条目 `dirent`；dirent 存储的是 文件名 -》 inode 的映射；（树形结构，就是 <font color=blue>目录文件 和 dirent 的实现</font>）

<font size=4>**-ln -s 软链接**</font>；**有独立的 inode 和 block**；<font color=blue>**软链接文件存储的是一段 path 路径**；这个路径直接指向源文件</font>；可以跨文件系统创建；

**—ln 默认 硬链接：没有新建文件（没有新的 innode，block）**，<font color=blue>只是在目录文件中，新增 dirent</font>；由于新旧两个 dirent 都是指向同一个 inode，那么就导致了一个限制：不能跨文件系统**。因为，不同文件系统的 inode 管理都是独立的。**

<img src="https://i.loli.net/2021/09/18/x3rMJcznVIm9Bpu.png" alt="image-20210918160505566" style="zoom:57%;" />

【NOTE】划重点：**硬链接只增加了一个 dirent 项，只修改了目录文件而已。不涉及到 inode 数量的变化**。新的 name 指向原来的 inode。

<font size=4>**-MV命令： **</font>

- **源 和目的，在同一个文件系统：mv 命令的核心操作是系统调用 rename ，通常操作是删除源文件所在目录文件中的 dirent，在目标目录文件中添加一个新的 dirent 项（不涉及数据拷贝，只修改元数据）**。inode number 不变，inode 不变，不增不减，还是原来的 inode 结构体，所以数据完全没有拷贝。
- 源和目的，不在同一个文件系统； 先 copy ，后 remove 。

<font size=4>**- cp 命令**</font>

真正的数据拷贝命令，即拷贝元数据，也会拷贝数据；

<font color=red size=4>【总结】</font>

**目录文件**是一种特殊的文件，可以理解成**存储的是 dirent 列表**。dirent 只是名字到 inode 的映射，这个是树形结构的基础；目录树在内存中确实是一个树的结构，每个节点由 dentry 结构体表示；



## ==fork的写时复制、vfork==

https://www.cnblogs.com/wuchanming/p/4495479.html

传统的 fork( ) 系统调用直接把所有的资源复制给新创建的进程。这种实现过于简单并且效率低下，且这样做常常是毫无意义的，**因为许多子进程通过装入一个新的程序开始它们的执行，这样就完全丢弃了所继承的地址空间。**

**<font size=4>在页根本不会被写入的情况下---例如，fork()后立即执行exec()，地址空间就无需被复制了</font>**

==**写时复制**==：**使地址空间上的页的拷贝**被推迟到实际发生写入的时候。<font color=red> **内核只为新生成的子进程创建虚拟空间结构，它们来复制于父进程的虚拟空间结构，但是不为这些段分配物理内存，它们共享父进程的物理空间，当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。**</font>

内核此时并不复制整个进程的地址空间，而是**让父子进程共享同一个地址空间**。只用**在需要写入的时候才会复制地址空间**，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。

<font color=red>**(重点，深入理解 “写时复制”)**</font>

​		对于写时复制：**在fork之后exec之前两个进程用的是相同的物理空间（内存区**），**子进程的代码段、数据段、堆栈都是指向父进程的物理空间**，也就是说，==**两者的虚拟空间不同，但其对应的物理空间是同一个**==。当父子进程中**有更改相应段的行为发生时**，**再为子进程相应的段分配物理空间**，如果==**不是因为exec**==，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而==**代码段继续共享父进程的物理空间（两者的代码完全相同**）==。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。   

  **vfork()**：这个做法更加火爆，**内核连子进程的虚拟地址空间结构也不创建了，直接共享了父进程的虚拟空间**，当然了，这种做法就顺水推舟的共享了父进程的物理空间。

**fork与vfork的区别**

vfork 用于创建一个新进程，而该新进程的目的是exec一个新程序。

- ​	区别一：不将父进程的地址空间复制到子进程。
- ​	区别二：vfork保证子进程先运行，在它调用exec或（exit）之后父进程才可能被调度运行。

<font color=purple>**写时复制（COW）的实际应用**</font>：Redis 的持久化机制中，如果采用 bgsave 或者 bgrewriteaof 命令，fork 一个子进程来将数据存到磁盘中。Redis 的读取操作多，因此这种情况下使用 COW 可以减少 fork() 操作的阻塞时间。

## 零拷贝技术

通过尽量减少拷贝操作来缓解 CPU 的压力。

假如一个应用需要从某个磁盘文件中读取内容通过网络发出去，像这样：

`while((n = read(diskfd, buf, BUF_SIZE)) > 0)write(sockfd, buf , n);`

整个过程就需要经历：1）**read** 将数据**从磁盘文件**通过 DMA 等方式**拷贝到内核开辟的缓冲区**；2）数据**从内核缓冲区复制到用户态**缓冲区；3）**write** 将数据从用**户态缓冲区**复制到内核协议栈开辟的 **socket 缓冲区**；4）数据从 **socket 缓冲区**通过 DMA 拷贝到**网卡**上发出去。整个过程发生了**至少四次数据拷贝**。

1. #### mmap

​		使用 mmap 来代替 read，可以==减少一次拷贝操作==。 <font color=\#9999CC> mmap 函数用于申请一段内存空间，将这段内存作为 进程间 通信的共享内存。</font>

​		<font color=\#9999CC>**mmap** 是一种**内存映射文件**的方法</font>，将一个文件或者其它对象映射到进程的地址空间，**实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系**。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以**实现不同进程间的文件共享**。如下图所示：

<img src="https://images0.cnblogs.com/blog2015/571793/201507/200501092691998.png" alt="img" style="zoom:80%;" />

​	**2、sendfile () 函数**，只发生在内核态的数据传输接口，没有用户态的参与，自然避免了用户态数据拷贝。只能将**数据从文件传递到套接字**上。使用 `sendfile` 不仅减少了数据拷贝的次数，还减少了上下文切换，数据传送始终只发生在`kernel space`。

​	**3、splice 函数**，只适用于将数据从文件拷贝到套接字上。**splice调用在两个文件描述符之间移动数据**，而不需要数据在内核空间和用户空间来回拷贝。

​	4、写时复制

​	5、缓冲区共享

## exec 函数

fork 函数创建新的  子进程后，子进程 <font color=#ff00000>**往往要调用 exec 函数 以执行另一个程序。**</font>当进程调用 exec 函数时，该进程执行的程序 完全替换为 新程序，调用 exec 并不创建新进程，前后的 进程ID 并未改变。

## vfork 函数

vfork 函数用于 创建一个  新进程，该新进程的目的是  exec 一个新程序。<font color=blue>**vfork 创建的 子进程，并不 复制 父进程的 地址空间**</font>，因为 子进程会  立即调用 exec，执行新的程序。**vfork  保证 子进程先运行**，在 它调用  exec 或 exit 之后，父进程  才可能被调度运行。vfork 的子进程共享 父进程的虚拟内存和物理内存，



### 系统如何发送信号给进程？

https://blog.csdn.net/waltonhuang/article/details/52229336

**<font color=red>内核给进程发送信号，是在进程所在的进程表项的信号域设置对应的信号的位。</font>**

**进程检查信号的时机是：进程即将从内核态返回用户态时。**

进程有一个链表的数据结果，维护一个未决信号的链表。信号在进程中注册，其实就是把该信号加入到这个未决信号链表当中。可靠信号不管链表中是否已经有这个信号了，还是会加进去。不可靠信号，如果链表中已经有这个信号了，就会忽略。

执行用户自定义的信号处理函数的方法很巧妙。**把该函数的地址放在用户栈栈顶，进程从内核返回到用户态的时候，先弹出信号处理函数地址，于是就去执行信号处理函数了，然后再弹出，才是返回进入内核时的状态。**

用户进程对信号的响应有三种方式：

1. 忽略信号，对信号不做任何处理，但是有两个信号是不能忽略的，即SIGKILL,SIGSTOP
2. 捕捉信号，定义信号处理函数，当信号发送时，执行相应的自定义处理函数
3. 执行缺省操作，linux对每种信号都规定了默认操作

## 异常

<font size=4 color=red>异常分为四类：中断（异步），陷阱，故障、终止（同步，是执行当前指令的结果）</font>

**<font color=red>异常（陷阱，故障、终止）：CPU内部出现的中断</font>**，CPU在执行特定指令时出现的非法情况；也称为**“同步中断”**；因此**只有在一条指令执行后才会发出中断。**

**<font color=red>中断（异步中断）</font>**：CPU对系统发生某事件时的一个响应。与指令无关（中断**<font color=red>由硬件设备产生</font>**，如 **I/0 中断，时钟中断**）

**<font color=red>陷阱</font>**：**系统调用**

**故障：**比如缺页异常，

**终止：**不可恢复的致命错误造成的结果。比如程序异常（除 0 操作）

- 相同点：**都是由CPU发送给内核，由内核处理。**

- 不同点：产生源不同，异常由CPU内部产生，中断由硬件设备产生

**<font color=red>软中断是执行中断指令产生的，而硬中断是由外设引发的。</font>**硬中断是可屏蔽的，软中断不可屏蔽。



# （三）Linux 网络编程

## IO同步、异步与多路复用

IO 两个阶段

1. 数据准备阶段。内核从设备读取数据到内核空间的缓冲区
2. 内核空间复制回用户空间进程缓冲区阶段

 IO 读写：

1. <font color=#ff00000>内核从IO设备读数据</font>
2. <font color=#ff00000>进程从内核复制数据</font>（将数据从内核缓冲区读入 用户缓冲区）

**同步和异步的概念描述的是用户线程与内核的交互方式**

- <font color=#ff00000>同步</font>：用户线程 发起IO请求 后需要 **等待或者轮询 内核IO操作完成**后才能继续执行；
- <font color=#ff00000>异步</font>：用户线程发起IO请求后仍继续执行，**当内核IO操作完成后会通知用户线程**，或者**调用用户线程注册的回调函数**

**同步**等待应答结果，是**主动去获取消息结果**，而**异步**是等待通知,**等别人给他通知**（回调函数）

<font color=\#9999CC>同步和异步 的本质区别</font>是 ------》，<font color=#ff00000>请求发起方对消息结果的获取是主动发起的，还是等被动通知的</font>。

​		如果是请求方主动发起的，一直在等待应答结果（同步阻塞），或者可以先去处理其他的事情，但要不断轮询查看发起的请求是否有应答结果（同步非阻塞 ）因为不管如何都要发起方主动获取消息结果，所以形式上还是同步操作。

​		如果是由服务方通知的，也就是请求方发出请求后，要么在一直等待通知（异步阻塞），要么就先去干自己的事了（异步非阻塞），当事情处理完成之后，服务方会主动通知请求方，它的请求已经完成，这就是异步。<font color=blue>异步通知的方式一般是通过状态改变，消息通知，或者回调函数来完成，大多数时候采用的都是回调函数。</font>	

**同步I/O模型要求用户代码自行执行I/O操作；异步I/O由内核来执行I/O操作**



### 同步和阻塞（重新整理）

可以认为，一个IO操作包含两个部分：

- 发起 IO 请求
- 实际的 IO 读写操作

**同步和异步**  在于第二个，实际的IO读写操作，如果内核帮你完成后再通知你，那就是异步，否则都叫做同步。

**阻塞和非阻塞**    在于第一个，发起 IO 请求，对于 非阻塞来说，发起 IO 请求后，就返回了。



## select、poll、epoll 的区别

- <font color=\#9999CC size=5>**select**</font> ：将已连接的 Socket 都放到一个**文件描述符集合**，然后调**用 select 函数将文件描述符集合拷贝到内核里**，让**内核来检查是否有网络**事件产生，检查的方式很粗暴，就是通过**遍历**文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着**再把整个文件描述符集合拷贝回用户态里**，然后用户态还需要再通过**遍历**的方法找到可读或可写的 Socket，然后再对其处理。
- <font size=5 color=red>select </font>需要进行 **2 次「遍历」文件描述符集合**，一次是在内核态里，一个次是在用户态里 ，而且还会发生 **2 次「拷贝」文件描述符集合**，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。
- <font color=\#9999CC>**poll()的机制**</font> 与 select() 类似，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是 poll **没有最大文件描述符数量的限制**。**poll 和 select 同样存在一个缺点：包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间**。

<font color=red>**select** </font>使用 <font color=#ff00000>**线性表**</font> 描述  文件描述符集合，**文件描述符有上限**（1024）；<font color=#ff00000> **poll**</font>  使用 <font color=#ff00000>**链表**</font> 来描述；<font color=#ff00000>  **epoll** </font>底层通过 <font color=#ff00000>**红黑树**</font> 来描述，并且<font color=red>**维护一个 ready list**</font>，用来存储已经就绪的事件，在使用 epoll_wait 调用时，仅观察这个list中有没有数据即可。

**select 和 poll**  的最大开销 来自 内核**判断是否有文件描述符就绪**  这一过程：**每次执行select或poll调用时，它们会采用轮询的方式，遍历整个文件描述符集合去判断各个文件描述符是否有活动**；

epoll 总结：**一棵红黑树和一个list链表就解决大并发的问题。**<font color=blue>**epoll_create时   创建红黑树和就绪链表，epoll_ctl   时添加到红黑树中（若存在则不添加）并向内核注册回调函数。epoll_wait  时返回list就绪链表里面的数据就可以了。**</font>

<img src="https://i.loli.net/2021/08/26/ZNKBPboxD1mwnWl.png" alt="image-20210826110025547" style="zoom:50%;" />

#### 使用ET和LT的区别

- LT：使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束，目的是告诉我们有数据需要读取；
- ET：使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，服务器端只会从 epoll_wait 中苏醒一次，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；

一般来说，边缘触发的效率比水平触发的效率要高，因为**边缘触发可以减少 epoll_wait 的系统调用次数**，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。

#### ET模式下的读写注意事项

 当epoll工作在ET模式下时，对于读操作，**如果read一次没有读尽buffer中的数据，那么下次将得不到读就绪的通知，<font color=red>造成buffer中已有的数据无机会读出，除非有新的数据再次到达</font>**。对于写操作，主要是因为ET模式下fd通常为非阻塞造成的一个问题——**<font color=red>如何保证将用户要求写的数据写完</font>**。要解决上述两个ET模式下的读写问题，我们必须实现：

- 对于读，<font color=blue>只要buffer中还有数据就一直读</font>；
- 对于写，<font color=blue>只要buffer还有空间且用户请求写的数据还未写完，就一直写</font>。

如果使用边缘触发模式，I/O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会**循环**从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，程序就没办法继续往下执行。所以，<font color=red>**边缘触发模式一般和非阻塞 I/O 搭配使用**</font>，**程序会一直执行 I/O 操作，直到系统调用（如 `read` 和 `write`）返回错误，错误类型为 `EAGAIN` 或 `EWOULDBLOCK`。**

##### <font color=purple>解决方法（非阻塞模式）</font>

- 读: **只要可读, 就一直读**, 直到返回 0, 或者 errno = EAGAIN；
- 写: **只要可写, 就一直写**, 直到数据发送完, 或者 errno = EAGAIN



#### LT模式下会不停触发socket可写事件，如何处理？

- <font color=red>**需要向socket写数据的时候才把socket加入epoll，等待可写事件**</font>。接受到可写事件后，调用write或者send发送数据。<font color=red>**当所有数据都写完后，把socket移出epoll**</font>。
- **使用ET模式（边沿触发）**，这样socket有可写事件，只会触发一次。
- 在epoll_ctl()使用**EPOLLONESHOT**标志，当事件触发以后，**socket会被禁止再次触发**。



### sleep( ) 和 wait( ) 函数的区别?

- sleep( )，当线程处于上锁时，不会释放对象锁，即睡眠时也持有对象锁。只会让出CPU执行时间片，并不会释放同步锁。
- wait( )，会释放对象锁；sleep 可以在任何地方使用，而 wait 只能在同步块中使用。



# （四）操作系统

## 1、计算机内存与主存的关系

<img src="https://img-blog.csdnimg.cn/2019050210533621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTAzNDc5,size_16,color_FFFFFF,t_70" alt="img" style="zoom:70%;" />

内存 = 主存 + 高速缓存。计算器内存条采用的是<font color=blue>DRAM(动态随机存储器)，即计算机的主存。</font>

高速缓冲存储器Cache主要是为了解决CPU和主存速度不匹配而设计的。<font color=blue>Cache一般由SRAM(静态随机存储器)芯片实现</font>，它的存取速度接近CPU，快于DRAM，存储容量小于DRAM

<img src="https://img-blog.csdnimg.cn/20190502103840256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTAzNDc5,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />



## 2、i++ 是不是原子操作？（不是）

++i 主要有3个步骤；把数据从内存放在寄存器上，在寄存器上进行自增，把数据从寄存器拷贝到内存。每个步骤都可能被中断。



## 3、在Linux/win平台下，栈空间的大小？

<font color=\#9999CC>**win 是编译器决定栈的大小**</font>，记录在可执行文件中，<font color=\#9999CC>**默认是1M**</font>。<font color=red>**linux 下由os 决定，在环境变量中设置**</font>，<font size=5>**ulimit -s** 命令查看修改</font>

在Linux下通过如下命令可查看和设置栈的大小：

```
$ ulimit -a            # 显示当前栈的大小 （ulimit为系统命令，非编译器命令）       
$ ulimit -s 32768      # 设置当前栈的大小为32M
```



##  4、内核空间和用户空间是怎样区分的

​		在Linux中虚拟地址空间范围为 0 到 4G，**最高的 1G 地址**（0xC0000000到0xFFFFFFFF）供内核使用，称为**内核空间**，**低的3G空间**（0x00000000到0xBFFFFFFF）供各个进程使用，就是**用户空间**。

​		内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。

<img src="../AppData/Roaming/Typora/typora-user-images/image-20210606105742393.png" alt="image-20210606105742393" style="zoom:50%;" />

### 4.1  ==为什么要区分 内核态和用户态？(重要)==

**最简单的运行程序的方式是“直接执行”，即直接在 CPU 上执行任意程序**。直接执行的问题是：

1. **如何限制代码行为？**比如禁止：设置特殊寄存器的值、访问存储器的任意位置、I/O 请求、申请更多系统资源等
2. **在运行这个程序的时候，如何切换到另一个程序**？进程调度应该是 OS 才有的权限

因此引入用户态和内核态和两种模式。**用户态无法执行受限操作，如 I/O 请求**，执行这些操作会引发异常。核心态只能由操作系统运行，可以执行特权操作。用户程序通过**系统调用**system call 执行这些特权操作。OS 执行前会判断进程是否有**权限**执行相应的指令。

**区分用户态和核心态的执行机制称为“受限直接执行**”。

**—内核态：** **CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡。**

**—用户态：** 只能受限的访问内存, 且不允许访问外围设备。占用CPU的能力被剥夺, CPU资源可以被其他程序获取。

#### 4.2 <font color=blue>**用户态   切换到  内核态   的3种方式**</font>：

- <font color=red>系统调用</font>（陷阱，软中断）
- <font color=red>中断</font>（**当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号**，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，）中断包括 I/O 中断、外部信号中断、各种定时器引起的时钟中断等；
- <font color=red>异常</font>：（缺页中断）

#### 4.3 陷阱、中断、异常和信号

1.  <font color=blue size=4>**陷阱（也被称为软中断，同步中断）**</font>的主要作用是实现**系统调用**。比如，进程可以执行 `syscall n` 指令向内核请求服务。当进程执行这条指令后，会中断当前的控制流，**陷入**到内核态，执行相应的系统调用。内核的处理程序在执行结束后，会将结果返回给进程，同时退回到用户态。进程此时继续执行**下一条指令**。

2. <font color=blue size=4>**中断**</font>由**处理器外部的硬件**产生，不是执行某条指令的结果，也无法预测发生时机。由于中断独立于当前执行的程序，因此中断是异步事件。（中断包括 I/O 设备发出的 I/O 中断、各种定时器引起的时钟中断、调试程序中设置的断点等引起的调试中断等。）

3. <font color=blue size=4>**异常（也称为 故障）**</font>是一种错误情况，是执行当前指令的结果，可能被错误处理程序修正，也可能直接终止应用程序。异常是同步的。（常见的异常：除法错误、缺页异常......）

   

## 5、==虚拟内存 （Linux 内存管理）==

<font color=blue size=4>**linux的内存管理采取的是分页存取机制（4级页表存储）**</font>，为了保证物理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。

### 虚拟内存解决了什么问题？（百度3面）

(1)安全风险：

　　用户有可能在程序中操作不当，直接操作了某个未知的物理地址，导致数据被改写。有可能导致那部分内存的程序或者设备损坏。

　　**使用虚拟地址的话，会有相对应的保护机制。**

<font color=red>**让每个进程有独立的地址空间 (进程间的安全)**</font>

https://blog.csdn.net/tommy_wxie/article/details/8668406

<font size=4>（深入理解计算机系统） **虚拟存储器作为存储器保护的工具**</font>

**PTE ( page table entry)。通过在 PTE 上添加一些额外的许可位来控制对一个虚拟页面内容的访问。**

1. <font color=red>**物理内存本身是不限制访问的**</font>，任何地址都可以读写，**而操作系统要求不同的页面具有不同的访问权限**，这是**<font color=red>利用CPU模式和MMU的内存保护机制实现的</font>。**例如，**Text Segment被只读保护起来**，防止被错误的指令意外改写，内核地址空间也被保护起来，防止在用户模式下执行错误的指令意外改写内核数据。这样，**执行错误指令或恶意代码的破坏能力受到了限制**，顶多使当前进程因段错误终止，而不会影响整个系统的稳定性。

   > **MMU**：内存管理单元，主要用来管理虚拟存储器、物理存储器的控制线路，同时也负责**虚拟地址映射为物理地址**，以及提供硬件机制的**内存访问授权**、多任务多进程操作系统。
   >
   > 执行过程：
   >
   > **操作系统和MMU是这样配合的：**
   >
   > 1. 操作系统在初始化或分配、释放内存时会执行一些指令在物理内存中填写页表，然后用指令设置MMU，告诉MMU页表在物理内存中的什么位置。
   > 2. 设置好之后，**CPU每次执行访问内存的指令都会自动引发MMU做查表和地址转换操作**，地址转换操作由硬件自动完成，不需要用指令控制MMU去做

   <font color=red size=4>段错误是这么产生的：</font>

   1. 用户程序要访问的一个VA，经MMU检查无权访问。
   2. MMU产生一个异常，CPU从用户模式切换到特权模式，跳转到内核代码中执行异常服务程序。
   3. 内核把这个异常解释为段错误，把引发异常的进程终止掉。

2. <font size=4>虚拟内存管理最主要的作用是<font color=red>**让每个进程有独立的地址空间 (进程间的安全)**</font></font>

   所谓独立的地址空间是指，**不同进程中的同一个VA被 MMU 映射到不同的 PA,并且在某一个进程中访问任何地址都不可能访问到另外一个进程的数据，这样使得任何一个进程由于执行错误指令或恶意代码导致的非法内存访问都不会意外改写其它进程的数据**，不会影响其它进程的运行，从而保证整个系统的稳定性。另一方面，**每个进程都认为自己独占整个虚拟地址空间，这样链接器和加载器的实现会比较容易，不必考虑各进程的地址范围是否冲突。**

3.  <font size=4>**VA到PA的映射会给分配和释放内存带来方便**</font>

   <font color=red size=4>**物理地址不连续的几块内存可以映射成虚拟地址连续的一块内存。**</font>

4.  一个系统如果同时运行着很多进程，为各进程分配的内存之和可能会大于实际可用的物理内存，虚拟内存管理使得这种情况下各进程仍然能够正常运行。

   因为各进程分配的只不过是虚拟内存的页面。也许页面的数据可以映射到物理页面，也可以临时 保存在磁盘上。磁盘上临时保存虚拟内存页面可能是一个磁盘分区或者文件（对换区）

   

<font color=purple>当创建一个进程时，**操作系统会为该进程分配 4GB大小的虚拟进程地址空间**。之所以是 4GB，**是因为在32位操作系统中，一个指针的长度是 4字节**。4 字节指针的寻址能力是 0x00000000 ~0xFFFFFFFF</font>

紧凑：将 内存中的所有作业进行移动，使它们全部都邻接，即可把 原来分散的多个空闲小分区拼接成一个大分区。**每次 “紧凑”后，都必须对 移动了的程序 进行重定向。**

**分页：** 将 **用户程序的地址空间**   分成若干个固定大小的区域，”**页**“。将   **内存空间**  分为若干个**物理块**，”**页框**“。分页地址 中的地址结构：页号 + 位移量

**页表（存储在内存中）**：在  分页系统中，允许将   进程的各个页   离散地存储在内存的任一物理块中。 <font color=red>**页表，存储着   页面编号  和 页框编号的   对应关系。**</font>【补充：<font color=red>**Linux（x86_64) 使用 4级页表**</font>】**页表的级数**，是在**映射速度和页表占用空间**中取折中。

**地址变换机构： 将  逻辑地址  中的页号，转换为  内存中的物理块号。**

**由于 页表 存放在内存中，CPU 每存取一个数据时，都要 访问内存 两次。第一次，访问 内存中的页表，根据页号找到对应的物理块号，将 物理块号 和 偏移量  拼接，得到  物理地址。第二次访问内存时，从 第一次所得的地址中 获得数据（或写入数据）。**

<font color=red>**TLB（快表）， 页表的cache，加快查询，一次内存访问。**</font>

<font color=\#9999CC>**虚拟存储器：**</font> 具有  <font color=\#9999CC>**请求调入功能 和 置换 功能**</font>，能从   逻辑上对内存容量加以扩充的一种   存储器系统。逻辑容量  由 内存容量和外存容量之和  所决定。（<font color=#ff0000000>**基于局部性原理**</font>）

- 多次性：一个作业中 的程序和数据，<font color=red>**无需**在作业运行时**一次性全部装入内存**，只需要将  **当前要运行**的部分程序和数据，**装入内存。**</font>
- 对换性：无须  在作业运行时  一直常驻内存，**允许  在作业运行过程中 进程换进、换出。**
- **虚拟性：从逻辑上  扩充内存容量。**

**分页请求系统**： 在  基本的分页系统上，增加了  **请求调页** 功能和   **页面置换**功能。

- 请求分页的页表机制（状态位 P：指示该 页是否已调入内存；访问字段 A：记录在一段时间内  访问的次数；修改位 M；外存地址）

  只有当  执行进程 需要某个页面时，才加载页面。

- 缺页中断机制

- 地址变换机构

<font size=4>**页面 置换算法**</font>

- **最佳置换 算法：淘汰以后不会使用的，或者是在长时间内不再访问的页面**，以保证获得最低的缺页率。（只有进程在执行中才知道接下来要访问哪个页面，操作系统无法预知。所以该 算法无法实现）
- **先进先出  置换算法(FIFO**)：淘汰最早进入内存的页面，就是在内存中驻留最久的页面。
- **最近最久未使用  置换算法(LRU)：选择最近最长时间没有被访问的页面**（需要寄存器和栈的硬件支持）
- **时钟置换算法(CLOCK**)：最多会循环扫描两次缓冲区；每个页面设置一个访问位，内存中的所有页面通过指针链接成一个循环队列。当某个页面被访问时，将访问位置为1；当要淘汰一个页面时，检查访问位，如果为0，就换出。否则将 1 置为0，暂不换出。
- **改进的时钟置换算法**：考虑到页面被修改过；为每个页面设置，(访问位，修改位)，第一轮换出(0,0)，第二轮淘汰(0,1)，第三轮(0,0)；第四轮(0,1);



### 5.1、局部性原理

​		<font color=#ff0000000>**局部性原理**</font>  分为时间局部性与空间局部性。 **<font color=#ff0000000>时间局部性</font>**：程序中的一条指令一旦执行，不久后该指令还可能再次被执行。产生时间局部性的原因是程序中**<font color=#ff0000000>存在大量的循环操作</font>**。 **<font color=#ff0000000>空间局部性</font>**：**一旦程序访问了某个存储单元，在不久后，其附近的存储单元也会被访问。**因为**<font color=#ff0000000>指令的顺序通常是顺序存储、顺序执行的</font>**。数据的存储也是向量、数组、表等形式。

​		基于局部性原理，在程序装入内存时，只会将程序的一部分装入内存，就可以启动程序。在程序执行过程中如果所需要的信息不在内存中，可以由操纵系统将需要的那一部分数据再调入内存。如果操作系统暂时不适用某些内容，可以将其调到外存上，从而腾出空间供别的作业使用。以上就称为**虚拟存储器**。



### 5.2、逻辑地址 转 物理地址

​		页表寄存器(PTR)，存放页表在内存中的 起始地址F 和 页表长度M；进程未执行时，页表存放在进程控制块（PCB）中，进程被调度时，内核把页表放在PTR。	其中，**页表（PTR）存放在内存中，快表 是 单独的寄存器。**

​		<font color=blue>虚拟地址（逻辑地址A）= 页号+偏移量</font>；通过 **页号 在页表中查找对应的物理块号**，进而<font color=blue>转化为  物理地址。</font>

<font size=4>**设 页面长度为 L，若手算，则 页号P=(A/L)，偏移量W=(A%L)；**</font>

> 例：若页面大小L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。
>
> 等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占10位(说明一个页面的大小为2^10B = 
>
> 1KB)，页号2对应的内存块号 b=8，将逻辑地址A=2500转换为物理地址E。

​	<img src="../AppData/Roaming/Typora/typora-user-images/image-20210321101946088.png" alt="image-20210321101946088" style="zoom:65%;" />

### 5.3、页面抖动

<font size=4>频繁的页面调度行为，称为“抖动” 或“颠簸”；产生抖动的主要原因是：**进程频繁访问的页面数目 高于 可用的物理块数目（分配给进程的物理块数目不够**）</font>

###  5.4、内存交换中，被换出的进程保存在哪里？

保存在 磁盘中，也就是外存；通常把 磁盘空间 分为 文件区和<font size=4 color=red>对换区</font>。在对换区中采用连续分配的方式。



## 6、==内存管理==（<font color=#ff0000000>malloc 的底层实现</font>）

分配内存有两种方式：<font color=#ff0000000>**brk 和 mmap 系统调用**</font>

1. **brk 是将数据段(.data) 的最高地址指针_edata往高地址推；**
2. **mmap** 是在进程的虚拟地址空间中（**堆和栈的中间**，称为 文件映射的区域）**找一块空闲的虚拟内存**。

这两种方式<font color=red>**分配的都是虚拟内存。**</font>

1. **malloc 小于128 bytes，使用brk分配**。将 _edata往高地址堆（**只分配虚拟内存**，不对应物理内存（因此没有初始化），**第一次读/写数据时，引起内核缺页中断**，内核才分配对应的物理内存，然后和虚拟内存建立映射关系）
2. **malloc 申请大于128k的内存，使用mmap 分配**。在堆和栈之间找一块空间内存分配（初始化为0）



## 7、进程 /线程 

对于，操作系统而言，进程就是一个 数据结构；Linux 源码：

```
struct task_struct {
	long	state;    	                //进程状态
	struct mm_struct  *mm;             // 虚拟内存结构体
	pid_t			  pid;			  // 进程号
	struct task_struct __rcu  *parent;  // 指向父进程的指针
	struct list_head		children;   // 子进程列表
	struct fs_struct		*fs;        // 存放文件系统信息的指针
	struct files_struct		*files;    // 一个数组，包含该进程打开的文件指针
};

```

`task_struct`就是 Linux 内核对于一个进程的描述，也称为「进程描述符」。

其中，**mm_struct 中有两个字段，pgd 和 mmap**；pgd 指向第一级页表（基址），**mmap 指向 vm_area_structs（区域结构**）的链表。

vm_area_strcuts 包含了 vm_start，vm_end，vm_prot（读写权限），vm_flags，vm_next；

通过 vm_start / vm_end 来判断缺页异常。

### 7.1、什么是文件描述符

先说`files`，它是一个文件指针数组。一般来说，一个进程会从`files[0]`读取输入，将输出写入`files[1]`，将错误信息写入`files[2]`。

**每个进程被创建时，`files`的前三位被填入默认值，分别指向标准输入流、标准输出流、标准错误流。我们常说的<font color=red>「文件描述符」就是指这个文件指针数组的索引</font>**，所以程序的文件描述符默认情况下 0 是输入，1 是输出，2 是错误。

<img src="../AppData/Roaming/Typora/typora-user-images/image-20210606110617965.png" alt="image-20210606110617965" style="zoom:50%;" />

<font size=4>输入重定向 | 输出重定向</font>

输入重定向：程序想读取数据的时候就会去`files[0]`读取，所以我们只要把`files[0]`指向一个文件，那么程序就会从这个文件中读取数据，而不是从键盘：

输出重定向：就是把`files[1]`指向一个文件，那么程序的输出就不会写入到显示器，而是写入到这个文件中；

**管道符**其实也是异曲同工，把一个进程的输出流和另一个进程的输入流接起一条「管道」，数据就在其中传递；



<font color=\#9999CC>**进程**</font>，**一个正在执行的程序实例**。进程是 动态的，程序是 静态的。进程 是**系统资源分配的基本单位。**

<font color=\#9999CC>**线程是 CPU调度和分派的基本单位**</font>。

进程，作为 系统中 拥有资源的基本单位。**<font color=red>线程</font>** 不拥有 系统资源，但线程专属 <font color=#ff0000000>有 TCB(线程控制块)，**程序计数器、 寄存器 和 栈空间**。</font><font size=4> **一个进程的 所有信息，对该进程的所有线程都是共享的，包括  可执行程序的代码、程序的全局内存 和 堆内存，栈以及文件描述符。</font>（补充：PC程序计数器，用于存放指令的地址）**

<font size=4>系统调用`fork()`可以新建一个子进程，函数`pthread()`可以新建一个线程。**但无论线程还是进程，都是用`task_struct`结构表示的，唯一的区别就是共享的数据区域不同**。</font>



### 7.2、多线程、多进程

**应用场景**

1. <font color=purple>**多进程的应用场景**</font>
   1. <font color=red>**nginx主流的工作模式是多进程模式**</font>（也支持多线程模型） （nginx：HTTP和反向代理web服务器）
   2. 几乎所有的web server服务器服务都有多进程的，至少有一个守护进程配合一个worker进程，如   apached，httpd  等等
   3. <font color=red>**chrome浏览器也是多进程方式**</font>。 （原因：①可能存在一些网页不符合编程规范，容易崩溃，**采用多进程一个网页崩溃不会影响其他网页；而采用多线程会**。②**网页之间互相隔离，保证安全，**不必担心某个网页中的恶意代码会取得存放在其他网页中的敏感信息。）
2. <font color=purple>**多线程的应用场景**</font>
   1. **线程间有数据共享，并且数据是需要修改的（不同任务间需要大量共享数据或频繁通信时）**
   2. **有IO交互的应用，良好的用户体验（键盘鼠标的输入，立刻响应）**

**多进程优点：**

1. 每个进程 相互独立，子进程崩溃不影响主程序的稳定性。
2. 可以尽量减少线程加锁/ 解锁的影响。

**缺点：**

- 逻辑控制复杂；多进程 调度开销大

**多线程优点：**

1. 所有线程可以直接共享内存和变量等；
2. 线程调度开销小

**缺点：**

- 线程之间的同步和加锁麻烦；**一个线程崩溃可能影响到整个程序的稳定性；**

**<font color=#ff0000000>进程 由  代码段、数据段、堆栈段 组成。</font>**

父进程 创建 子进程之后，除了 pid外，几乎一样。**父、子进程共享全部数据（包括 文件描述符、内存地址空间、程序计数器、执行的代码等）**，对同一块数据的读写操作，子进程在读写数据时，主要通过 **写时复制**。子进程通过调用   **execv函数**，调用执行自己的代码段 。

**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。**

**<font color=red>并发执行</font>**：在时间段内==（同一时间段==），同时执行。

**<font color=red>并行执行</font>**：在 某个具体的时间点（==同一时刻==）上，有 多个进程同时执行。**（需要硬件支持；如多流水线、多核处理器或分布式计算）**



### 进程间的通信

- 管道（pipe）只能和父子进程之间通信；命名管道(FIFO)允许任意两个进程之间通信，通过命令 mkfifo 或者系统调用创建；

**管道的原理**：管道是半双工的，数据只能向一个方向流动。需要双方通信，需要建立两个管道。创建管道 pipe ( )。field[0] 读，field [1] 写。通常是，在父进程创建管道，再创建子进程。由于子进程复制了父进程打开的文件描述符，所以父子进程就可以通过管道通信。

- 信号量、信号、消息队、<font color=blue>**共享内存（最快的IPC方式）**</font>、套接字



### 线程同步

https://blog.csdn.net/s_lisheng/article/details/74278765

* 临界区
* 信号量
* **条件变量**   pthread_cond_t
* 锁机制（读写锁、互斥锁、自旋锁）;一次只有 一个线程 可以占有  写模式的读写锁，但是  多个线程 可以同时占有读模式的读写锁。

**互斥锁**：一次只能一个线程拥有互斥锁，其他线程只有等待；明显的缺点在于只要两种状态（锁定和非锁定）。

**条件变量**：通过 阻塞线程，并等待另一个线程发送信号的方式，弥补互斥锁的不足。**条件变量 与 互斥量 一起使用时，允许 线程以无竞争的方式等待特定的条件发生。**

<font color=blue>总结：互斥锁是进程间互斥的机制，而条件变量是 同步机制。</font>



###  同一个进程内的线程会共享什么资源（重点）？

* 该进程的地址空间
* 全局变量
* 堆空间
* 文件描述符

**<font color=#ff0000000>线程的栈空间是自己独有的</font>**

### 为什么线程需要独占资源？

- 线程 ID；一组寄存器的值；
- 栈，每个线程中的函数调用过程是独立的。因此需要有独立的栈；
- 错误返回码：系统调用或库函数发生错误时，会设置全局错误码 errno，每个线程的错误返回码应该是独立的；
- 信号屏蔽码：每个线程所感兴趣的信号不同，所以<font color=blue>线程的信号屏蔽码应该由线程自己管理，但每个线程都共享本进程的信号处理器。</font>



### 多线程和线程池的区别？

当服务器与客户端 TCP 完成连接后，通过 `pthread_create()` 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。

如果每来一个连接就创建一个线程，线程运行完后，操作系统还得销毁线程，虽说线程切换的上写文开销不大，**但是如果频繁创建和销毁线程，系统开销也是不小的。**

- <font color=VioletRed>线程池在程序运行开始，创建好 N个线程，并阻塞等待任务的到来。而 **多线程是在任务到来的时候创建，然后才执行任务。**</font>
- 线程池中的线程执行完后不会回收线程，继续将线程放入等待队列中；而多线程在每次任务结束后都会回收线程。
- 由于线程池中的线程是创建好的，所以在效率上相对于多线程会高很多

<font color=red>既然为每个请求分配一个进程/线程的方式不合适，那有没有可能只使用一个进程来维护多个 Socket 呢？那就是 **I/O 多路复用**技术。</font>

**select / poll / epoll 内核提供给用户态的多路复用系统调用，进程可以通过一个系统调用函数从内核中获取多个事件。**



### ==（重点）Linux 中进程和线程是如何创建的==

vfork( )、fork( )、pthread_create( ) 都会<font color=red>调用系统内核的 do_fork( )</font> 函数来实现，而 <font color=red>do_fork 主要调用 copy_process。</font>

copy_process( )主要完成 进程数据结构，各种资源的初始化。<font color=red>初始化方式</font>可以重新分配有也可以共享父进程资源，<font color=red>主要通过传入的参数决定。</font>

实际上，进程和线程都是用一个结构体，<font color=red>task_struct 来表示一个执行任务的实体。</font>

<font color=purple>**Linux 内核提供了创建进程的接口 do_fork( )。并提供了 两个系统调用 _clone( )和fork( )，最终都用不同的参数调用 do_fork( ) 内核API**</font>。 do_fork( ) 提供了很多参数，包括 CLONE_VM（共享内存空间）、CLONE_FS（共享文件系统信息）、CLONE_FILES（共享文件描述符表）、CLONE_SIGHAND（共享信号句柄表）和 CLONE_PID。

- <font color=purple>**当使用 fork( )系统调用产生多进程时，内核调用 do_fork( ) 不适用任何共享属性**</font>，进程拥有独立的运行环境。
- <font color=purple>**当使用 pthread_create( ) 来创建线程时，则最终设置了所有这些属性来调用 _clone( )**</font>，而这些参数又全部传给 do_fork（），从而创建的“进程” 拥有共享的运行环境，只有栈是独立的，由  _clone( )传入。

<font size=4 color=red>**总结：Linux 下不管是多线程 还是 多进程，最终都是 do_fork 实现的多进程。只是 进程创建时的参数不同，从而导致有不同的共享环境。**</font>



## 线程(pthread_create、pthread_join)

1. 用 <font color=blue> **pthread_create 创建新线程时**</font>，并不能保证 哪个线程会先运行。

2. <font color=blue>**pthread_exit /  pthread_ join**</font>：当 一个线程 通过调用 pthread_exit 退出或简单地从 启用例程中 返回时，线程中的  其他线程 可以调用 <font color=#ff0000000>pthread_join 函数获得该线程的退出状态。</font>
3. <font color=blue>**pthread_cond_wait  |  pthread_cond_signal**</font> （线程间 用 条件变量 进行同步。cond 条件变量 一般和 互斥锁（pthread_mutex_lock） 结合。）

## Linux中常用C/C++一些头文件的作用

https://blog.csdn.net/hzraymond/article/details/8162478



### 可重入函数 / 锁

<font color=blue> 可重入锁：可重入锁最大的作用是避免死锁。</font>

一个程序可以在任意时刻被中断，然后系统去执行另外一段代码，结束后又调用继续原来的子程序不会出错，则称其为可重入。

**从根本上来说**：

- 可重入函数只使用自己栈上的变量，不依赖任何外部数据，可以允许有该函数的多个副本在运行，因为每个调用者产生的函数栈都是相互独立的；
- 不可重入函数使用了一些系统资源，如果被中断的话，可能会出现问题；
- 各种锁：死锁，自旋锁，乐观锁，悲观锁

### 协程

**可以被暂停和恢复运行的函数**。子程序在执行时中断并转去执行别的子程序，在适当的时候又返回来继续执行。

<font color=red>协程会在函数被暂停运行时保存函数的运行状态，并可以从保存的状态中恢复并继续运行。当你在协程中写下yield的时候就是想要暂停该协程，当使用next()时就是要再次运行该协程。</font>

（协程如何做到，可以被暂定和恢复运行的？）**在堆区中申请一段空间，然后保存协程的整个栈区，当需要恢复协程的运行时再从堆区中copy出来恢复函数运行时状态。(x)，不需要来回拷贝数据。对于协程，直接在堆区中开辟栈帧空间即可**

使用协程，理论上我们可以**开启无数并发执行流，只要堆区空间足够**，同时还没有创建线程的开销，<font color=#ff0000000>**所有协程的调度、切换都发生在用户态**</font>。

<font size=4 color=blue>如何使用协程</font>

- **yield：**让出当前的CPU，**跳转到指定的位置进行执行**，这个过程叫做  yield
- **next：**上面 yield  让出CPU之后跳转到指定的位置执行，当指定的位置执行完成之后，**回到当初的位置这个过程叫做 next**。
- <font color=blue> 协程适用于 I/O密集型，和异步IO相结合</font>

<img src="https://i.loli.net/2021/08/26/ZMeKVd8F5PEoiC6.png" alt="image-20210826114255078" style="zoom: 40%;" />

### 多线程比，协程有何优势？

1. 协程极高的执行效率。因为子程序切换不是线程切换，只在用户态不会陷入内核态。**没有线程切换的开销**
2. **不需要多线程的锁机制**
3. <font color=red>**一个线程的多个协程的运行是串行的**</font>。一个线程内的多个协程虽然可以切换，但是多个协程是串行执行的，只能在一个线程内运行，没法利用CPU多核能力。。
4. <font color=red> 线程在多核环境下能做到真正的并行；而协程是为 并发而生</font>

### 各种锁

#### ==操作系统是如何实现锁的？==

**所谓的锁，就是内存中的一个整型数**，拥有两种状态：空闲状态和上锁状态。加锁时，判断锁是否空闲，如果空闲，修改为上锁状态，返回成功；如果已经上锁，则返回失败。解锁时，则把锁状态修改为空闲状态。

加锁的过程，用伪代码表示：

```
1、read lock；
2、判断lock状态；
3、如果已经加锁，失败返回；
4、把锁状态设置为上锁；
5、返回成功。
```

<font color=blue>两个核会并行操作内存，而且从操作内存这个调度来看“test and set”不是原子的，**需要先读内存然后再写内存**，如果我们保证这个内存操作是原子的，就能保证锁的正确性了。确实，<font size=4>**硬件提供了锁内存总线的机制**</font>，我们在锁内存总线的状态下执行test and set操作，就能保证同时只有一个核来test and set，从而避免了多核下发生的问题。</font>

**<font color=red>[总结：]	在硬件层面，==CPU提供了原子操作、关中断、锁内存总线的机制==；OS基于这几个CPU硬件机制，就能够实现锁；</font>**



**互斥锁：**当有一个线程要访问共享资源（临界资源）之前，会对线程访问的这段代码（临界区）进行加锁。如果在  加锁之后没释放锁之前  其他线程要对临界资源进行访问，则这些**线程会被阻塞睡眠**，直到解锁。

**自旋锁**：自旋锁访问加锁资源时，如果无法获得锁，不会立即放弃CPU，会**一直循环的查看是否释放锁**。这样要比互斥锁效率高很多，但是仍然需要占用CPU。所以<font color=#ff0000000>自旋锁适用于多核的CPU。其实，自旋锁就是一种等待机制，即忙等待</font> 

##### ==互斥锁和自旋锁的差别==

- 互斥锁加锁失败后，会**从用户态陷入到内核态**，**让内核帮助我们切换线程**，虽然简化了使用锁的难度，但是存在一定的性能开销成本。（可能导致死锁发生）

> 性能开销成本：两次线程上下文切换的成本。
> 1、当线程加锁失败时，内核将线程的状态从【运行】切换到睡眠状态，然后把CPU切换给其他线程运行；
> 2、当锁被释放时，之前睡眠状态的线程会变成就绪状态，然后内核就会在合适的时间把CPU切换给该线程运行；
>
> 所谓 **线程上下文切换**，主要是指：
> 	当两个线程属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，<font color=#ff0000000>只需要切换线程的私有数据、寄存器等不共享的数据</font>

- 自旋锁：**在用户态完成加锁和解锁操作**，不会主动产生线程上下文切换，相比互斥锁来说，会快一些开销小一些。
- **互斥锁 得不到资源的时候阻塞，不占用cpu资源；自旋锁得不到资源的时候，不停的查询，占用CPU（不推荐使用 while 循环获取锁，Intel CPU 提供 了 [PAUSE] 指令。）**

#### 互斥锁和自旋锁使用的场景

互斥锁请求锁失败会陷入内核态，会有线程上下文切换的开销。如果 <font size=4>**能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。**</font>



### 【乐观锁 | 悲观锁】

**乐观锁（读多写少；操作数据前不加锁，直到数据提交的时候才检验）**：当线程去拿数据的时候，认为别的线程不会修改数据，就**不上锁**。

**悲观锁（写多；先取锁再访问）**：当线程去拿数据的时候，**总假设别的线程会去修改数据**，所以它**每次**拿数据的时候**都会上锁**，别的线程去拿数据的时候就会阻塞。**（使用  select .... for update 方式，即通过排他锁的方式实现了悲观锁）**

<font size=4 color=blue>悲观锁例子：行锁、表锁、读锁、写锁等，都是在操作之前先上锁。</font>

<font size=4 color=blue>乐观锁：MVCC 快照读；乐观锁不用 锁机制，而是用业务代码（冲突检测 和 数据更新）</font>

比较典型的是：<font color=red size=4>CAS（乐观锁）</font>（compare and swap）



## 死锁产生的条件

1. 互斥：一个资源只能被一个进程使用；

2. 占有并请求：一个进程因请求资源而阻塞，而对已获得的资源保持不放。

3. 不可剥夺：进程对已获得的资源，在未使用之前，不能强行剥夺。

4. 循环等待

   

## 孤儿进程、僵尸进程（僵尸进程留下的资源：进程号、退出状态、运行时间）

- 孤儿进程：父进程退出后，子进程还在执行，这些子进程就变成孤儿进程，被 **init 进程（id=1）**收养。

- 僵尸进程。子进程完成退出后，**父进程没有使用 wait或者 waitpid**对它们的状态进行收集。它们的文件描述符还留在系统中，这些子进程就成为僵尸进程。

  - <font color=red>**僵尸进程中子进程未释放的资源是什么？**</font>
    - <font color=purple>**在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。**</font>  ==<font color=blue>**但是仍然为其保留一定的信息(包括进程号、退出状态、运行时间等)。**</font>==  如果进程**不调用 wait/waitpid** 的话，那么保留的那段信息就不会释放，**其进程号就会一直被占用**，但是**系统所能使用的进程号是有限的**，如果大量的产生僵死进程，**将因为没有可用的进程号而导致系统不能产生新的进程。* 此即为僵尸进程的危害，应当避免。

-    <font color=blue>子进程结束后为什么要进入僵尸状态?</font>

     因为父进程可能要取得子进程的退出状态等信息。

- <font color=red>**如何查看僵尸进程？  ps -aux  进程状态为 “Z”，就是僵尸进程。**</font>

### 如何避免僵尸进程

- 父进程 调用  <font color=red>wait() 或 waitpid()</font>，通知内核释放僵尸进程。
- 采用<font color=red>signal（SIGCHLD，SIG_IGN)</font>，忽略 SIGCHLD（**在一个进程终止或者停止时，将SIGCHLD信号发送给其父进程**），<font color=blue>通知内核对子进程的结束不关心，由内核回收。（常用于高并发，由init 进程回收僵尸进程的资源）</font>
- 在信号处理函数 中调用 wait 函数。
- 让僵尸进程变成孤儿进程，由 init 回收，就是让父亲先死


### 怎么回收线程？

- **等待线程结束；pthread_join**(pthread_t tid; void** retval )；父线程调用该函数并阻塞，直到子线程退出并回收其资源。
- 结束线程 pthread_exit(void** retval); 子线程调用
- 分离线程 pthread_detach(pthread_self ( ) )；主、子线程均可调用，调用后，子线程结束时自己回收资源；



### ==C++使用多线程交替打印1~10==

```
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

int number;
mutex mutex_number;

const int MAXNUM = 10;

// 打印奇数
void add_1() {
    while (1) {
        mutex_number.lock();
        if (number >= MAXNUM) {
            mutex_number.unlock();
            break;
        }
        if (number % 2 == 0) {
            number++;
            cout << "mythread_1: " << number << endl;    // 输出
        }

        mutex_number.unlock();
    }
    cout  << "mythread_1 finish" << endl;     // mythread_1完成
}

// 打印偶数
void add_2() {
    while (1) {
        mutex_number.lock();

        if (number >= MAXNUM) {
            mutex_number.unlock();
            break;
        }
        if (number % 2 == 1) {
            number++;
            cout << "mythread_2: " << number << endl;    // 输出
        }

        mutex_number.unlock();
    }
    cout  << "mythread_2 finish" << endl;     // mythread_2完成
}

int main() {
    number = 0;
    cout << endl << "Create and Start!" << endl;

    thread mythread_1(add_1);
    thread mythread_2(add_2);

    mythread_1.join();
    mythread_2.join();

    cout << endl << "Finish and Exit!" << endl;
    return 0;
}
```



## 单例模式中的懒汉模式 和 饿汉模式：

单例模式作为最常用的设计模式之一，==保证一个类仅有一个实例==，并提供一个访问它的全局访问点，**==该实例被所有程序模块共享==。**

==懒汉模式==，即非常懒，不用的时候不去初始化，所以**在第一次被使用时才进行初始化**；经典的<font color=#ff0000>线程安全懒汉模式，使用双检测锁模式。</font>

```
class single{
private:
    //私有静态指针变量指向唯一实例
    static single *p;
    //静态锁，是由于静态函数只能访问静态成员
    static pthread_mutex_t lock;
    //私有化构造函数
    single(){
        pthread_mutex_init(&lock, NULL);
    }
    ~single(){}
public:
    //公有静态方法获取实例
    static single* getinstance();

};

pthread_mutex_t single::lock;
single* single::p = NULL;
single* single::getinstance(){
// 双重检验的原因：第一次判断是为了验证是否创建对象，第二次判断是为了避免重复创建单例，因为可能会存在多个线程通过了第一次判断在等待锁，来创建新的实例对象。
    if (NULL == p){
        pthread_mutex_lock(&lock);
        if (NULL == p){
            p = new single;
        }
        pthread_mutex_unlock(&lock);
    }
    return p;
}
```

<img src="C:\Users\AaronCM\AppData\Roaming\Typora\typora-user-images\image-20210131211522199.png" alt="image-20210131211522199" style="zoom:70%;" />

但是，**在 C++11以后，使用局部变量懒汉不用加锁**。

==饿汉模式==，即迫不及待，在程序运行时立即初始化。**饿汉模式不需要用锁**，就可以实现线程安全。原因在于，在程序运行时就定义了对象，并对其初始化。之后，不管哪个线程调用成员函数getinstance()，都只不过是返回一个对象的指针而已。所以是线程安全的，不需要在获取实例的成员函数中加锁。

```
class single{
private:
    static single* p;
    single(){}
    ~single(){}

public:
   static single* getinstance();
};
single* single::p = new single();
single* single::getinstance(){
    return p;
}
//测试方法
int main(){
    single *p1 = single::getinstance();
    single *p2 = single::getinstance();

    if (p1 == p2)
        cout << "same" << endl;

    system("pause");
    return 0;
}
```

饿汉模式虽好，但其存在隐藏的问题，在于非静态对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。



# （五）计算机网络

### OSI 模型

OSI 模型  有7层（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）

- 表示层：图像、视频编码解，数据加密。
- 会话层：建立会话，如session认证、断点续传。

TCP/IP 模型 4层结构（链路层、网络层、传输层、应用层）

## socket 网络编程有哪些系统调用？其中 close 是一次就能直接关闭的吗？半关闭状态是怎么产生的？

**socket、bind、listen、connect、accept、send 、receive**

**用close 会将该socket 引用计数-1**，如果引用还是大于0，那么 socket端口状态保持不变**，如果为0，**会将 sender缓冲区中的数发出去，然后**发送 FIN**，可能在 多进程中出现  半关闭，<font color=red>**使用 shutdown，直接关闭描述符，直接到 LAST_ACK 状态。**</font>

<font color=red>CLOSE_WAIT产生的原因是，被动关闭的一方收到 FIN请求后没有发送 FIN包。</font>

### <font color=blue>大量 CLOSE_WAIT 连接 的原因</font>

<font size=4>close_wait之后会返回一个ack给客户端，如果还在这个状态，说明服务器卡住了，耗时太长。</font>

<font color=blue>**大量 Time_WAIT 连接 的原因**</font>

<font color=red>**存在大量的高并发短连接；**</font>高并发可以让服务器在短时间范围内同时占用大量的端口；短连接表示 “ 业务处理+传输数据 ” 的时间远小于 TIMEWAIT超时的时间；

<font color=red>如何处理：打开系统的TIMEWAIT重用和快速回收；</font>

==**TCP上的 keep alive 机制（解决大量无用连接无法回收）**==

TCP 保活机制，就是为了保证连接的有效性，<font color=red>在间隔一定的时间发探测包</font>，根据回复确认该连接是否有效。

在双方交互过程中，可能存在以下的几种情况：

- 客户端或 服务器端 意外断电、死机、进程挂掉重启等
- 网络出现问题，连接双方无法知道一直等待
- 程序问题导致的长时间 CLOSE_WAIT

**TCP 的 keep_alive机制 可以解决大量无用连接无法回收、占用资源的问题。**



### 服务器回应RST的原因：

- 终端访问服务器未开放的端口，服务器回复 RST 报文；
- **服务器关闭或异常终止了连接，由于网络问题，客户端没有收到服务器的关闭请求，这称为TCP半打开连接。**
  就算重启服务器，也没有连接信息。如果客户端向提其写入数据，对方就会回应一个RST报文段。
- 请求超时；



## TCP、UDP

- TCP 面向连接，UDP是无连接的。
- TCP 提供可靠的服务，通过TCP传输的数据，无差错、不丢失、不重复、按序到达。UDP 尽最大努力交付。
- TCP 面向字节流，可能发送粘包问题；*UDP **面向数据报，没有拥塞控制，传输速率高***（适用于  实时性要求高的应用，如 视频、音频等多媒体通信）
- **TCP 首部字段 20 字节；UDP 首部字段 8 字节**

### TCP对应的应用层协议

FTP：定义了文件传输协议，使用21端口。

Telnet：它是一种用于远程登陆的端口，23端口。

SMTP：定义了简单邮件传送协议，服务器开放的是25号端口。

POP3：它是和SMTP对应，POP3用于接收邮件。

### UDP对应的应用层协议

DNS：用于域名解析服务，用的是53号端口；

SNMP：简单网络管理协议，使用161号端口；

TFTP(Trival File Transfer Protocal)：简单文件传输协议，69



## TCP

==TCP 提供一种  面向连接、可靠的字节流服务。==（因为 面向字节流，所以 不保留消息边界）**套接字： 地址+端口号**。TCP 可以被描述为 “一种带累积正向确认的滑动窗口协议 ”

<font color=#ff0000000>TCP 头部20字节</font>

<img src="../AppData/Roaming/Typora/typora-user-images/image-20210214160652873.png" alt="image-20210214160652873" style="zoom:80%;" />

序列号，32位的无符号数，<img src="../AppData/Roaming/Typora/typora-user-images/image-20210218145527755.png" alt="image-20210218145527755" style="zoom:60%;" /> 16位 窗口大小，是TCP流量控制。16位 校验和，不仅包括TCP头部，还包括 数据部分。

TCP 传输 是可靠的。首先 **TCP 采用 确认机制**，即 发送端发送的每个TCP报文段 都必须得到接收方的应答，才认为 TCP报文段传输成功。其次，TCP 协议**采用 超时重传机制**，发送端在发送出一个TCP报文段后，启动定时器，如果在 定时时间内未收到应答，将重发报文。最后，由于接收端接收到的报文  可能乱序、重复。TCP协议会**对接收到的报文进行重排**，**按序交付**报文段给应用层。

### 半关闭状态

TCP 连接是全双工的，它允许两个方向上的数据传输被独立关闭。通信的一端 可以发送FIN结束报文段给对方，告诉对端  本端已经完成数据的发送。但  允许 继续接收来自 对端的数据，直到对端也 发送FIN报文段。

> ​	判断 对方是否已经关闭连接的方法是：**read 系统调用返回 0；**

### ==TIME_WAIT 状态==（状态转移）

<img src="../AppData/Roaming/Typora/typora-user-images/image-20210226103936055.png" alt="image-20210226103936055" style="zoom:67%;" />

客户端 ==**在接收到 服务器的结束报文段并发送ACK报文后**，并没有 直接进入  CLOSED状态，而是  转移到 TIME_WAIT 状态。==

在 这个状态下，客户端要等待 2MSL(Max Segment Life，**报文段最大生存时间**)  的时间，才能完全关闭。 

**<font color=#ff0000000>TIME_WAIT 状态存在的原因：</font>**

1. **可靠地终止 TCP连接**
2. **保证    让迟来的TCP报文段有   足够的时间被识别并丢弃。**

> **可靠地终止连接**：假设  用于确认  接收到服务器结束段的ACK报文丢失，那么   服务器将重发 结束报文段。因此 客户端需要停留在某个 转态 的、以处理重复接收到的结束报文段（即向 服务器发送 确认报文段）
>
> **保证让迟来的TCP报文段被丢弃：**  一个 TCP 端口无法被同时打开多次。当 一个TCP连接处于 TIME_WAIT 转态时，无法使用该端口新建连接。 如果没有TIME_WAIT ，则 应用程序可以立即和一个刚关闭连接的端口  建立连接。该  新连接 可能会接收到属于原来连接的TCP报文段。   <font color=#ff0000000>采用2MSL ，确保 两个传输方向上的数据都已被丢弃，**使得  新连接 可以在 2MSL后 安全地建立。**</font>



## ==TCP 3次握手，4次挥手==

* #### 三次握手

第一次握手：首先 **client端**  给 server 发送连接请求报文，在这个报文中，包含了**SYN=1，client_seq=任意值 i**，**发送之后处于SYN-SENT状态**，这是第一次握手；

第二次握手：**server端 ** 接收到了这个请求，并分配资源，同时**给client返回一个ACK报文**，这个报文中呢包含了这些字段，**标志位SYN和 确认报文段ACK  都为1，确认号ack=i+1**，此时位于**SYN-RCVD状态**，这是第二次握手

第三次握手：**client**收到server发来的ACK信息后呢，他会看到server发过来的小ack是i+1，这时他知道了server收到了消息，也给server**回一个ACK报**文，报文中同样包含了ACK=1这样的消息，同时呢，还包括了client_ack=k+1这样的字段，三次握手之后，连接就建立了，client**进入established（已建立连接）状态**

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9saWFjekQxOE9pY1N3WXdISHJpY3BsOUdXaEtab3cwcExqbkZVT29CSnRBR2VHNFgxOFJTanlvNUhITHFpYXR1emw5ZlpRbERQOVR3VGliVjlFMTRTMEVUZFh3LzY0MA?x-oss-process=image/format,png" alt="img" style="zoom:67%;" />

* #### 四次挥手断开连接：

TCP断开连接通常是由一方主动，一方被动的，这里我们假设client主动，server被动
第一次挥手：当**client**没有数据要发送给server了，他会给server**发送一个FIN报文**，告诉server：“我已经没有数据要发给你了，但是你要是还想给我发数据的话，你就接着发，但是你得告诉我你收到我的关闭信息了”，这是第一次挥手，挥手之后**client进入FIN_WAIT_1的**第一阶段

第二次挥手：当**server**收到client发来的FIN报文后，告诉client：“我收到你的FIN消息了，但是你等我发完的”此时**给client返回一个ACK信息**，并且呢ack=seq+1，这是第二次挥手，挥手之后呢**server进入CLOSE_WAIT阶段**，而**client收到之后处于FIN_WAIT_2**第二阶段

第三次挥手：当**server**发完所有数据时，他会**给client发送一个FIN报文**，告诉client说“我传完数据了，现在要关闭连接了”，然后呢server变**成LAST_ACK状态**，等着client最后的ACK信息，这是第三次挥手

第四次挥手：**当client收到这个FIN报文时**，他会对这个消息进行确认，即给server发ACK信息，但是它不相信网络，怕server收不到信息，它**会进入TIME_WAIT状态**，万一server没收到ACK消息它可以可以重传，**而当server收到这个ACK信息后**，就正式关闭了 tcp连接，**处于CLOSED状态**，而**client 等待  2MSL**这样长时间后还没等到消息，它知道server已经关闭连接了，于是乎他自己也断开了，这是第四次挥手，这样**TCP 连接就断开**了



## 为什么是 3次握手，不是2次或者4次

1. ==第一次握手==：客户端发送网络包，服务端收到了。 这样==服务端就能得出结论==：<font color=red size=4>客户端的发送能力、服务端的接收能力是正常的。</font>
2. ==第二次握手==：服务端发包，客户端收到了。 这样==客户端就能得出结论==：<font color=red size=4>服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</font>
3. ==第三次握手==：客户端发包，服务端收到了。 这样==服务端就能得出结论==：<font color=red size=4>客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</font>

<font size=4>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</font>

<font size=4 color=purple>如果是 两次握手，会导致出现如下的情况：</font>

> 客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在**某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求**，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，**此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。**

 

## TCP 如何保证可靠性？

- 校验和
- 确认应答+序列号：TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把  有序数据传送给应用层。
- 超时重传
- 流量控制：可变大小的滑动窗口协议。  当 接收端 来不及处理发送方的数据，会提示发送端降低发送速率，防止包丢失。
- 拥塞控制

## UDP 如何实现可靠传输？

​		因为 UDP 是无连接的协议，所以在传输层无法保证可靠的传输。要想  **实现可靠的传输，只能从  应用层实现**。需要**实现 sqp/ack 机制、重传机制  和窗口确认机制**。 实现 接收方收到 UDP回复确认包，当 发送方没有接收到确认包，则重传。如果频繁发生丢包，则 控制发送方的发送窗口大小。**添加 发送/接收 缓冲区**，主要用于超时重传。

## TCP 拥塞控制

<font color=blue>目的：防止数据被过多注网络中导致网络资源（路由器、交换机等）过载</font>。因为拥塞控制涉及网络链路全局，所以属于全局控制。控制拥塞使用拥塞窗口。

拥塞窗口：大小为任何时候发送端可以往网络发送的字节数。

**拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。**

-  <font color=#ff0000000>慢启动：</font>当建立连接时，发送端 用很小的值初始化拥塞窗口。接着对每个重传计时器超时前得到的段，发送端的拥塞窗口增加一个段的字节量，此外，由于该段获得确认，网络中又少了一段。所以， <font color=#ff0000000>每个被确认的段允许发送两个段。每经过一个往返时间，拥塞窗口增加一倍，**呈指数增长**。</font>
- <font color=#ff0000000>慢启动阈值：</font>设置为  **当前拥塞窗口的一半**。
- <font color=#ff0000000>拥塞避免  (线性增长)：</font>当 窗口大小**达到 阈值时**，**改为 线性增加**窗口大小
- <font color=#ff0000000>快速重传：</font>当连续收到  **3个重复ACK时**，认为已经发送**丢包**，启动快速重传；此时 慢启动阈值设置为  拥塞窗口的一半，
- <font color=#ff0000000>快速恢复：</font>当 连续接收到 3个重复的ACK，认为丢包，开始快速重传，并 **乘法递减**，将**拥塞窗口 设置为 新的慢启动阈值（即当前拥塞窗口的一半）**，并**开始   线性增长**。在这种情况下，只有  第一次启动或发生超时，才进入 慢启动阶段。

![从连续收到三个重复的    确认转入拥塞避免](https://img-blog.csdn.net/20180610191132726?2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NodXhuaHM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## 流量控制

**主机B通过告诉主机A自己接收缓冲区的大小**，来使主机A控制发送的数据量。<font color=red>**流量控制与TCP协议报头中的窗口大小有关。**</font>

窗口的大小是**无需等待确认应答可以继续发送数据的最大值**。

- 操作系统内核为了维护这个滑动窗口，需要开辟**发送缓冲区**来**记录哪些数据还没有应答；只有确认应答过的数据才能在缓冲区中删除；**
- 在建立连接的时候已经确认了窗口的大小，确认了发送数据大小的上限；



#### 采用 流量控制，可能导致的问题（死锁可能，糊涂窗口综合征）

当窗口都为1就是停止-等待协议

若 **接收方的窗口为0，就会发送 零窗口大小的报文**，此时  发送方停止发送，直到  接收方发送一个 非零的接收窗口的报文。但是若 该更新窗口的报文丢失了，将**导致死锁**，**发送方一直等到非零窗口的报文**。

> <font color=blue>**解决方法：**</font>TCP为每个连接设置 一个<font color=#ff0000000>**持续计时器**</font>。只要 **接收到 零窗口通知，就启动该计时器**，<font color=#ff0000000>**周期性地发送  窗口探测报文段**</font>（1字节），对方就在确认这个报文段的时候给出窗口大小。（TCP 头部包括 窗口大小）



#### MTU、MSS分别是什么？

1. **MTU**：maximum transmission unit，**最大传输单元**，由硬件规定，如**以太网的MTU为1500字节。**
2. **MSS**：maximum segment size，**最大分节大小**，**TCP数据包每次传输的最大数据分段大小**，一般由发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据。**<font color=blue>MSS值为 MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到。</font>**

#### IP分片  与  TCP分段

- **IP分片**   产生的原因是**网络层的MTU**；
- **TCP分段**   产生原因是**MSS**;
- IP分片由网络层完成，也在网络层进行重组；TCP分段是在传输层完成，并在传输层进行重组
- 对于以太网，MSS为1460字节，而**MTU往往会大于MSS**；

<font size=4 color=red>如果采用 IP分片，某一片丢失则需要所有分片都重传；IP没有重传机制，所以需要等TCP发送方超时才能重传。因此，使用 IP分片，没有效率。</font>

故**<font color=blue>采用TCP协议</font>**进行数据传输，是**<font color=blue>不会造成IP分片的</font>**。若<font color=blue>数据过大</font>，只会<font color=blue>在传输层进行数据分段</font>，到了IP层就不用分片。而我们常提到的**<font color=blue>IP分片是由于UDP传输协议造成的</font>**，因**为UDP传输协议并未限定传输数据报的大小**。



## 有一个 IP 的服务器监听了一个端口，它的TCP的最大连接数是多少？

最大 TCP连接数=IP数*端口数

对于 IPV4，客户端的IP数最多为 2的32次方，端口数为2的16次方。所以TCP最大的连接数为2的48次方。

但最大并发TCP连接远不能达到理论上限，受限于    文件描述符的限制以及内存限制（每条TCP连接都要占用一定的内存）



## ==在浏览器中输入URL后执行的全部过程==

1. **DNS域名解析**，客户端使用 DNS协议将URL解析为 对应的IP 地址。（<font color=#ff0000000>**DNS协议将域名转换为IP地址，ARP协议将IP地址转换为MAC地址**</font>）

   ​	**DNS解析**  几个步骤：
   ​	1、**浏览器搜索自己的DNS缓存（本地缓存）**，缓存中维护了一张域名和IP地址的对应表；

   ​	2、若没有则搜索**操作系统的DNS缓存**；

   ​    3、若没有则**操作系统将域名发送到本地域名服务器**,本地域名服务器在自己的DNS缓存查找（递归查询）

   　4、若没有则通过以下方式查找（递归查询/迭代查询）

   　　　　**本地域名服务器向根域名服务器发送请求**，根域名服务器**返回com域顶级服务器域名**地址；

   　　　　**本地域名服务器向com域顶级域名发送请**求，com域顶级域名服务器**返回权限域名服务器**地址；

   　　　　本地域名服务器**向权限域名服务器发送请求，得到IP地址**；

   　　5、**本地域名将得到的IP地址返回操作系统，同时自己也将IP地址缓存起来**

   　　6、**操作系统得到IP地址返回给浏览器，同时自己也将IP地址缓存起来**

   　　7、浏览器得到IP地址

   ​	<font color=red>**DNS在进行区域传输的时候使用TCP协议，其它时候使用UDP协议；**</font>

   <img src="https://i.loli.net/2021/09/08/GcXTgSeP8QpAzkU.png" alt="image-20210908101013141" style="zoom:60%;" />

2. **建立 TCP连接**，客户端与服务器通过3次握手建立TCP连接。

3. **发送 HTTP请求**。客户端向服务器发送 http连接请求

4. **返回响应结果**；服务器对客户端发来的http请求进行处理，并返回响应

5. **关闭TCP连接**；

6. **浏览器解析HTML**

   

## ==HTTPS 是什么？==（百度、字节）

HTTPS 并不是新协议，而是<font color=blue> **在HTTP 和TCP层之间，加了一层SSL（secure socket layer） 通信，也就是说 HTTPS 使用了隧道进行通信**。</font>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。<font color=blue> **HTTPS 采用混合的加密机制。使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。**</font>

<font color=red>使用混合加密的原因：</font>

- 对称加密，只使用一个密钥，运算速度快。密钥必须保密，无法做到安全的密钥交换。
- 非对称加密，使用两个密钥，公钥和私钥。公钥可以任意分发，而私钥需要保密。解决了密钥交换问题，但速度慢。

<font color=red>**数字证书（将公钥放数字证书中）**</font>

**客户端先向服务器端索要公钥，然后⽤公钥加密信息，服务器收到密⽂后，⽤⾃⼰的私钥解密**。



==<font size=4>**SSL/TLS 协议建立的详细流程：**</font>==

https://blog.csdn.net/xiaoming100001/article/details/81109617

SSL 建立连接的过程

1. **client向serve**r发送请求[https://baidu.com](https://baidu.com/)，然后连接到server的443端口，**发送的信息主要是随机值1和客户端支持的加密算法。**
2. server接收到信息之后给予client**响应握手信息**，包括**随机值2和匹配好的协商加密算法**
3. server给client发送**第二个响应报文**是**数字证书**
4. **客户端**（TLS）解析证书，验证合法性。没问题的话，就**生成一个 预主密钥；**（数字证书最主要的内容：服务器公钥+ CA 的数字签名）
5. 客户端通过**随机值1、随机值2和预主秘钥组装会话秘钥**。
6. **然后通过证书的公钥加密会话秘钥。**客户端传送加密信息，这部分**传送的是用证书加密后的会话秘钥**
7. 服务器解密，得到和客户端一样的会话密钥。
8. 握手建立完成之后，通过 对称加密 通话。



==<font size=4 color=blue>**证书如何安全传输，被掉包了怎么办？**</font>==

- <font size=4>**数字证书内容**</font>

包括了**加密后服务器的公钥、权威机构的信息、服务器域名**，还有经过**CA私钥签名之后的证书内容**（经过先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名)，**签名计算方法**以及证书对应的域名。（NOTE：**数字签名= 数字摘要+ 密钥加密**）

- <font size=4>**验证证书安全性过程**</font>

  - 当<font color=blue>客户端</font>收到这个证书之后，<font color=blue>使用本地配置的权威机构的公钥对证书进行解密</font>得到**服务端的公钥和证书的数字签名**，数字签名经过**CA公钥解密得到证书信息摘要**。
  - 然后<font color=blue>用证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比（重点，可以识别中间人攻击）</font>，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。（理由：**因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，**但是篡改完成之后中间人需要将证书重新加密，但是**中间人没有权威机构的私钥，无法加密**，强行加密只会导致客户端无法解密，如果**中间人强行乱修改证书，就会导致证书内容和证书签名不匹配**。）

  

==<font size=4 color=blue>**第三方攻击者能否让自己的证书显示出来的信息也是服务端呢？**</font>==

<font color=red size=4>不能；</font>

因为当第三方攻击者去CA那边寻求认证的时候**CA会要求其提供例如域名的whois信息、域名管理邮箱等证明你是服务端域名的拥有者**，而第三方攻击者是无法提供这些信息所以他就是无法骗CA他拥有属于服务端的域名。

<font size=4>**中间人攻击**</font>

**中间人截取客户端发送给服务器的请求**，然后伪装成客户端与服务器进行通信；将服务器返回给客户端的内容发送给客户端，伪装成服务器与客户端进行通信

<font size=4 color=red>预防：</font>造成中间人劫持的原因是：没有对服务端证书及域名做校验或者校验不完整




## HTTP 1.0 /1.1/ 2.0的区别

<font color=red>**HTTP 1.0**</font>：只保持 **短暂连接**，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开连接；

<font color=#ff0000000>**HTPP1.1的特点：**</font>

- **默认持久连接**，节省通信量。Connection请求头的值为 **Keep-alive**

- **断点续传**：在 HTTP 请求上多定义了**断点续传相关的HTTP头 <font color=blue>`Range`和`Content-Range`字段</font>**；**HTTP1.1协议开始支持获取文件的部分内容，<font color=blue>客户端请求时对应是Range，服务器端响应时对应的是Content-Range。</font>**

**队头阻塞：**当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据。（<font color=blue>**HTTP管道化**要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。</font>）

<font color=red>**HTTP 2.0 特点**</font>

- **采用二进制格式，而非文本格式**（头信息和数据体都是二进制，并且统称为帧（frame）：**头信息帧和数据帧**。计算机收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这**增加了数据传输的效率**。）

- **压缩请求头**：对于 Header 中相同的数据，不会在每次通信中重新发送，而是采用**追加**或**替换**的方式。具体实现上，HTTP/2.0 在客户端和服务端之间共同维护一个 Header 表，存储之前发送的 key-value 对。Header 表在 HTTP/2.0 的连接期间始终存在。

- **多路复用（解决 1.1 中队头阻塞问题）**：一个连接中并发多个请求或回应，而不用按照顺序一一对应。（<font color=red size=4>对于HTTP1.1中管道化导致的请求/响应级别的队头阻塞</font>，可以使用HTTP2解决。<font size=4>**HTTP2**不使用管道化的方式，**而是引入了帧、消息和数据流等概念**</font>，每个请求/响应被称为消息，每个消息都被拆分成若干个帧进行传输，**每个帧都分配一个序号。**每个帧在传输是属于一个数据流，而一个连接上可以存在多个流，各个帧在流和连接上独立传输，到达之后在组装成消息，这样就避免了请求/响应阻塞。）

  

### Cookie | Session 

==好文链接==：https://www.cnblogs.com/fighter007/p/8439564.html

**cookie 和 session 就是用来跟踪用户的整个会话记录（放在 HTTP的请求头 或 响应头）**。**因为HTTP是无状态协议**，Cookie和 Session 可以弥补HTTP协议无状态的不足，用来跟踪会话。

<font color=red>**一个cookie的设置以及发送过程分为以下四步：**</font>

客户端发送一个http请求到服务器端；**服务器端发送**一个http响应到客户端，其中包含**Set-Cookie头部**；**客户端发送**一个http请求到服务器端，其中包含**Cookie头部**；服务器端发送一个http响应到客户端。

<font size=4>**Cookie的不可跨域名性（保证用户隐私安全）**</font>

Cookie在客户端是由浏览器来管理的，Cookie具有不可跨域名性。根据Cookie规范，浏览器访问Google只会携带Google的Cookie，而不会携带Baidu的Cookie。Google也只能操作Google的Cookie，而不能操作 Baidu 的Cookie。



#### 编码格式

**中文**属于**Unicode字符**，在内存中**占4个字符**，而**英文**属于**ASCII字符**，内存中只占**2个字节**。

<font color=blue>**Cookie中保存中文只能编码**。一般使用**UTF-8编码**即可</font>(不推荐使用GBK等中文编码，因为浏览器不一定支持，而且JavaScript也不支持GBK编码。)。**二进制使用 BASE64编码**，保存二进制图片

**Cookie 属性**

- **name** ：cookie 名称，一旦创建，无法更改。要更改只能创建同名的 cookie 进行替换。
- **value :**
- **maxAge**：失效时间。（<font color=blue>**<0 表示临时 cookie，浏览器关闭则cookie 失效；=0，删除cookie；默认 -1**</font>）
- **path:** cookie 的使用路径

- (关于 name  属性的补充) 如果要**删除某个Cookie**，只需要**新建一个同名的Cookie**，并将**maxAge设置为0**，并添加到response中覆盖原来的Cookie
- 

#### Session 

**Session 一种 key-value 的属性对。**（一个用户对应一个session id，服务器把 客户端的 session id 作为 cookie 返回给 客户端，以便后续对 会话进行跟踪和查找）

生命周期：Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。

<font color=blue>session 需要使用 cookie 作为识别标志。Session依据该Cookie来识别是否为同一用户。</font>

#### 客户端浏览器将Cookie功能禁用，或者不支持Cookie怎么办？

<font color=red>**URL地址重写**</font>是对客户端不支持Cookie的解决方案。URL地址重写的<font color=red>原理是将该用户Session的 id 信息重写到 URL地址中</font>。服务器能够解析重写后的URL获取Session的id。



## 网络层的各种协议（IP协议、ARP、ICMP、DHCP协议）

**IP协议**：IPV4协议的头部有 20字节。

**ARP协议**：地址解析协议。**将 IP地址 转换为MAC地址。**主机A想通过IP地址寻找到目标主机，**首先分析IP地址**确定目标主机与自己是否为**同一网段**。如果是则**查看ARP缓存，或者使用ARP协议发送广播**。如果不是，则寻找网关发送ARP数据包

**ICMP协议**：控制消息协议。当路由器在处理一个数据包的过程中发生了意外，可 通过 ICMP向数据包的源端报告有关事件。每一种ICMP消息类型都被封装在一个 IP数据包中。其中，ICMP消息类型包括（目的地不可达，超时，源抑制，重定向等）

**DHCP协议  动态主机配置协议**：动态配置一个IP地址



# （六） 数据库

### 关系型数据库和非关系型数据库

<font color=blue>**非关系型**</font>数据库的**优势**：

- NoSQL 是<font color=red>**基于键值对的**</font>，可以想象成表中的主键和值的对应关系，而且**不需要经过SQL层的解析**，所以**性能非常高**；
- 基于键值对，**数据之间没有耦合性**，所以非常**容易水平扩展**；
- **NoSQL**数据库**将数据存储于缓存**中，**关系型**数据库将**数据存储在磁盘**中，NoSQL 的查询速度更快。

<font color=blue>**关系型**</font>数据库的**优势**：

- **复杂查询**可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。
- <font color=red>**保持数据的一致性**</font> （最大的优势）

<img src="../AppData/Roaming/Typora/typora-user-images/image-20210318184632569.png" alt="image-20210318184632569" style="zoom:50%;" />



### 数据库有哪些引擎？

1. **MYISAM** : **全表锁，不支持事务。 非聚集索引**
2. **Innodb**：**行级锁**（SQL 都走索引查询），并发能力相对强，占用空间是 MYISAM 的 2.5 倍，不支持全文索引（5.6 开始支持），**支持事务。** **聚集索引**
3. **Memory** : **全表锁，存储在内存当中，速度快**，但会占用和数据量成正比的内存空间**且数据在 mysql 重启时会丢失**。

## 事务

https://blog.csdn.net/u013256816/article/details/103966510

**事务：一组原子性的 SQL查询**。事务内的语句，要么全部执行成功，要么全部执行失败。

事务需要满足  **==ACID 特性==**：

1. **原子性**   **使用 undo log** ，从而达到回滚
2. **一致性**   **使用 redo log**，从而达到故障后恢复
3. **隔离性**   使用锁以及**MVCC**
4. **持久性**   通过回滚，以及恢复

redo log在事务执行的过程中，不断记录事务操作的变化，**redolog有 prepare 和 commit两种状态**（保证 binlog 和 redolog 的一致性），**事务操作完成并且 binlog 写入完成时，redolog会从 prepare 状态转化为 commit 状态**。如在事务过程中发生系统故障，数据库会根据 redolog 的日志状态（prepare）恢复到事务前的状态。如事务已提交但数据未更新，则数据库 更新。（**binlog，Server 上的；binlog 是一种逻辑日志，而 redolog 是物理格式日志。binlog 在事务提交完成后一次性写入**。）

<font size=4>`undo log`和`redo log`并不是直接写到磁盘上的，而是先写入`log buffer`。再等待合适的时机同步到`OS buffer`，再由操作系统决定何时刷到磁盘。</font>

而这些<font color=red size=4>主要是靠日志恢复和并发控制实现的。</font>

* 日志恢复：数据库里有两个日志，一个是redo log，一个是undo log。<font color=#ff0000000>**redo log**</font> 记录的是已经成功提交的事务操作信息，用来恢复数据，保证事务的<font color=#ff0000000>**一致性**</font>。undo log记录的是事务修改之前的数据信息，用来回滚数据，保证事务的**原子性**。

* **MySQL的表数据是存放在磁盘上的**，因此想要存取的时候都要经历磁盘IO,然而即使是使用SSD磁盘IO也是非常消耗性能的。为此，为了提升性能**<font color=#ff0000000>InnoDB提供了缓冲池(Buffer Pool)</font>** ，Buffer Pool中包含了磁盘数据页的映射，可以当做缓存来使用：

* 读数据：会首先从缓冲池中读取，如果缓冲池中没有，则从磁盘读取再放入缓冲池；

* 写数据：会首先写入缓冲池，**缓冲池中的数据会定期同步到磁盘中；**

  因为我们的数据已经提交了，但此时是在缓冲池里头，还没来得及在磁盘持久化，所以我们急需一种机制需要存一下已提交事务的数据，为恢复数据使用。redo log，记录已经成功提交的事务操作。

  （1）redo log 的存储是顺序存储，而缓存同步是随机操作。

  （2）缓存同步是以数据页为单位的，每次传输的数据大小大于redo log。

  

* 并发控制：**并发控制主要靠读写锁和MVCC**（多版本并发控制）来实现。<font color=#ff0000000>**读写锁包括共享锁（S锁）和排他锁（X锁）**，保证事务的**隔离性**</font>。

## **==MVCC==**

### **快照读**和**MVCC**是什么关系呢？

MVCC是多版本并发控制，快照就是其中的一个版本。所以可以说<font size=4 color=blue>MVCC实现了快照读，具体的实现方式涉及到MySQL的隐藏列。**MySQL会给每个表自动创建三个隐藏列**。</font>

- `DB_TRX_ID`：**事务ID**，记录操作（增、删、改）该数据事务的事务ID
- `DB_ROLL_PTR`：**回滚指针**，**记录上一个版本的数据在`undo log`中的位置**
- `DB_ROW_ID`：**隐藏ID** ，创建表没有合适的索引作为**聚簇索引**时，会用该隐藏ID创建聚簇索引

由于`undo log`中记录了各个版本的数据，并且通过`DB_ROLL_PTR`可以找到各个历史版本，并且由`DB_TRX_ID`决定使用哪个版本（快照）。所以相当于**`undo log`实现了MVCC，MVCC实现了快照读。**

### 在 RR 隔离级别是怎么解决幻读的呢？

默认情况下，InnoDB工作在 RR 的隔离级别下，并且以Next-Key Lock的方式对索引行进行加锁。**当查询的索引具有唯一性**（主键、唯一索引）时，**Innodb存储引擎会对Next-Key Lock进行优化，将其降为行锁**，仅仅锁住索引本身，而不是范围（除非锁定不存在的值）。若是普通索引，则会使用Next-Key Lock将记录和间隙一起锁定。


### 什么是当前读和快照读

- 实际上MySQL在RR 隔离级别下，用MVCC解决了select 普通查询的幻读现象。
  具体的实现方式就是**事务开始时，第一条select语句查询结果集会生成一个快照（snapshot），并且这个事务结束前，同样的select语句返回的都是这个快照的结果**，而不是最新的查询结果，这就是MySQL在 RR 隔离级别 对 普通 select 语句使用的快照读。

不加锁的简单的 SELECT 都属于快照读，例如：

```
SELECT * FROM t WHERE id=1
```

与 快照读 相对应的则是 当前读，当前读就是读取最新数据，而不是历史版本的数据。<font color=red>**加锁的 SELECT 就属于当前读**</font>，例如：

```
SELECT * FROM t WHERE id=1 LOCK IN SHARE MODE;
SELECT * FROM t WHERE id=1 FOR UPDATE;   // 悲观锁的一种体现
```

<font color=blue>**select for update语句执行中所有扫描过的行都会被锁上**，这一点很容易造成问题。因此如果在MySQL中用悲观锁务必要确定走了索引，而不是全表扫描。</font>



### 隔离级别  (MYSQL的默认级别是，可重复读)

- <font color=red>RU（未提交读）</font>	事务可以读取  未提交的数据。==（**脏读：一个事务读取到另一个事务未提交的数据**）==

- <font color=red>**read committed (提交读) **</font>    ==**能够避免脏读，不可重复读**==（在一个事务内多次读取的结果不一样。）和 ==**幻读**==

- <font color=#ff0000000>**R R(可重复读)**</font>，==解决 脏读的问题。==该级别保证了  在同一个事务中多次读取同样记录的结果是一致的。 **MySQL 的默认事务隔离级别**，分别是采用读写锁以及MVCC。

  ​		采用读写锁实现：只要没释放读锁，再次读的时候还是可以读到第一次读的数据。

  ​		采用 MVCC实现：因为多次读取只生成一个版本，读到的自然是相同数据。==(乐观锁)==

- **可串行化**（最高的隔离级别），**会在读取的 每一行数据上都加锁（避免 并行化）**，可能导致大量的超时和锁争用的问题。==（悲观锁）==

<font size=4 color=red>select 默认执行的是 MVCC，RR，使用间隙锁解决 幻读</font>



## 数据库的索引类型

https://www.cnblogs.com/wezheng/p/8399305.html

 ==**<font color=blue size=5>每创建一个索引，就会新增一棵B+树，在做插入操作的时候，需要同时维护几棵树的变化，是耗时的。</font>**==



* **主键索引** 当关系表中定义主键时会自动创建主键索引。**每张表中的主键索引只能有一个**，要求主键中的每个值都唯一，即不可重复，也不能有空值。（主键索引 是特殊的唯一索引，**不允许有空值**）
* **唯一索引** 数据列不能有重复，可以有空值**。一张表可以有多个唯一索引，但是每个唯一索引只能有一列**。如身份证，卡号等。
* 普通索引 一张表可以有多个普通索引，可以重复可以为空值
* 全文索引 可以加快模糊查询，不常用

<font color=#ff0000000>**聚簇索引**</font>：是一种数据存储方式。**将数据行 直接存储在 叶子节点中。**

### 索引的 最左前缀 原则

​		b+树 的数据项是复合的数据结构，**比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据**；但当(20,F)这样的没有name的数据来的时候，b+树就不知道第一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。

关于最左前缀的使用，有下面两条说明：

- <font color=#ff0000000>**最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配**</font>，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
- =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

应尽量**避免在 where 子句中对字段进行 null 值判断**，否**则将导致引擎放弃使用索引**而进行全表扫描，如：

```
select id from t where num is null
```

<font color=#ff0000000>应考虑在 where 及 order by 涉及的列上建立索引</font>



## 索引的底层实现（重点）

==数据库的索引是使用<font color=#ff0000000>**B+树**</font>来实现的。==

B+ 树 对索引列是  **顺序组织**存储的。适合查找范围数据。B+树 上的叶子结点存储 关键字+数据。叶子结点以上各层作为索引使用。有 k 个子女的节点，并有 k个关键字。

**（为什么要用B+树，为什么不用红黑树和B树**）

<font color=red>B树的优势在于多路查找</font>，这便是优于红黑树的具体原因。但是，想一想，我**每个结点有多个key，而红黑树每个结点有一个key，**那么随着数据的不断增多，红黑树的高度不断增加，效率不断降低，**而B树的高度一般都很低**，为甚?我一个结点放上1024个key,满了才分裂一次

<font color=#ff0000000>B+树是一种特殊的平衡多路树</font>，是B树的优化改进版本，它把<font color=#ff0000000>所有的数据都存放在叶节点上，中间节点保存的是索引</font>。这样**一来相对于B树来说，减少了数据对中间节点的空间占用，使得中间节点可以存放更多的指针**，使得树变得更矮，深度更小，从而减少查询的磁盘IO次数，提高查询效率。另一个是**由于叶节点之间有指针连接，所以可以进行范围查询，方便区间访问。**

而<font color=#ff0000000>红黑树是二叉的</font>，它的**深度相对B+树来说更大**，更大的深度意味着查找次数更多，更频繁的磁盘IO，所以**红黑树更适合在内存中进行查找**。

索引 对 多个值进行排序的依据是，CREATE TABLE 语句中定义   <font color=#ff0000000>**索引时列的顺序。**</font>

**B+ 索引适用于  全键值、键值范围或键前缀查找**。

- 全值匹配：和 索引中的所有列 进行匹配。
- 匹配 最左前缀：只使用  索引的第一列
- 匹配 列前缀：只匹配 某一列的值的开头部分
- 匹配范围值：

**关于B+树索引的限制：**

- 如果不是按照 索引的最左列开始查找，则 无法使用索引；
- 不能跳过索引中的列。
- 如果 查询中有某个列的范围查找，则其右边所有列都无法使用索引优化查找。

### ==B树和B+树的区别（重点）==

这都是由于B+树和B具有不同的存储结构所造成的区别，以一个m阶树为例。

1. 关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。
2. **存储的位置不同**；**B+树**中的**数据都存储在叶子结点**上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是**B树**的**数据存储在每一个结点中**，并不仅仅存储在叶子结点上。B树每个节点都存储着 key和data；而B+树只有叶子节点存储了data
3. 分支结点的构造不同；**B+树**的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说**内部结点仅仅包含着索引信息。**
4. 查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说**B+树的搜索过程中走了一条从根结点到叶子结点的路径。**

==B+树优点：==由于**B+树**的数据都存储在叶结点中，分支结点均为索引，方便扫库，只需要**扫一遍叶子结点即可**，但是**B树**因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次**中序遍历按序来扫**，所以B+树更加适合在区间查询的情况，所以通常**B+树用于数据库索引，而B树则常用于文件索引。**



## MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？

MySQL建立索引有两种方式：用  ==alter table 或者create index。==

```
alter table table_name add primary key(column_list) #添加一个主键索引
alter table table_name add index (column_list)      #添加一个普通索引
alter table table_name add unique (column_list)     #添加一个唯一索引
```

```
create index index_name on table_name (column_list)   #创建一个普通索引
create unique index_name on table_name (column_list)  #创建一个唯一索引
```



## 什么是脏读，不可重复读和幻读？

* **脏读： A 事务读取到了 B事务未提交的内容，而B事务后面进行了回滚。**

  > 比如A向B转账100，A的账户减少了100，而B的账户还没来得及修改，此时一个并发的事务访问到了B的账户，就是脏读

* 不可重复读：对于数据库中的某一个字段，<font color=#ff0000000>一个事务**多次查询**却**返回了不同的值**</font>，这是由于在查询的间隔中，该字段被另一个事务修改并提交了。

  > 比如A第一次查询自己的账户有1000元，此时另一个事务给A的账户增加了1000元，所以A再次读取他的账户得到了2000的结果，跟第一次读取的不一样。

  **不可重复读与脏读的不同**之处在于，脏读是读取了另一个事务没有提交的脏数据，不可重复读是读取了已经提交的数据，实际上并不是一个异常现象。

* **幻读**：<font color=#ff0000000>事务**多次读取同一个范围**的数据，查询结果的**记录数**不一样</font>，这是由于在查询的间隔中，另一个事务新增或删除了数据。

  > 比如A公司一共有100个人，第一次查询总人数得到100条记录，此时另一个事务新增了一个人，所以下一次查询得到101条记录。

  **不可重复度和幻读的不同**之处在于，**幻读**是多次读取的**结果行数不同**，**不可重复读结果的**值不**同。

**==避免不可重复读需要锁行，避免幻读则需要锁表。==**



## 乐观锁与悲观锁

==<font color=red size=4>**悲观锁有行级锁和页级锁两种形式**</font>==。**行级锁对正在使用的单条数据进行锁定**，事务完成后释放该行数据，而**页级锁则对整张表进行锁定**，事务正在对该表进行访问的时候不允许其他事务并行访问。

**重点**：  **<font color=#ff0000000>（使用  select .... for update 方式，即通过排他锁的方式实现了悲观锁；MYSQL InnoDB默认是行级锁，行级锁是基于索引的，如果一条SQL语句用不到索引，则不会使用行级锁，会使用表级锁把整张表锁住）</font>**

悲观锁要求在整个过程中一直与数据库有一条连接，因为上一个事务完成后才能让下一个事务执行，这个过程是**串行的**。

**==乐观锁==有三种常用的实现形式：（网易一面）**

* 一种是在执行事务时把整个数据都拷贝到应用中，在数据更新提交的时候比较数据库中的数据与新数据，如果两个数据一摸一样则表示没有冲突可以直接提交，如果有冲突就要交给业务逻辑去解决。<font size=4 color=blue> CAS 原理</font>
* 一种是<font color=red>**使用版本戳来对数据进行标记，数据每发生一次修改，版本号就增加1。**</font>某条数据在提交的时候，如果数据库中的版本号与自己的一致，就说明数据没有发生修改，否则就认为是过期数据需要处理.
* 最后一种采用时间戳对数据最后修改的时间进行标记。与上一种类似。



### 查找成绩排名第二的学生

```
SELECT name, MAX(mark) as mark
FROM student
WHERE mark < (SELECT MAX(mark) FROM Student);
```

### 找出所有课程大于80分的sid，去重

```
SELECT DISTINCT stu_id 
FROM score sco 
WHERE sco.stu_id NOT IN (SELECT DISTINCT stu_id FROM score WHERE score<80);
```



# （七）海量数据的处理

https://www.cnblogs.com/think90/p/7629940.html

1. <font size=4>分而治之/hash映射 + hash统计 + 堆/快速/归并排序；</font>
2. <font size=4>Bloom filter/Bitmap；</font>
3. <font size=4>Trie树/数据库/倒排索引；</font>
4. <font size=4>外排序；</font>
5. <font size=4>分布式处理之Hadoop/Mapreduce。</font>

#### ==bitmap==

<font color=#ff0000000>**bitmap 位图法**：**用每一位来存放状态**</font>，**适用于大规模数据，但数据状态又不是很多的情况**。==<font color=red size=4>**通常用来判断某个数据存不存在。**</font>==

数据结构： **unsigned int bit [N]**；在这个数据里，可以存储 **N* sizeof(int)*8**个数据。（1字节= 8 bits）

unsigned char bit[8*1024]，能存储 8k * 8=64k 个unsigned short 数据。

##### <font size=4>给40亿个不重复的 unsigned int 整数，没排过序，然后再给一个数，如何快速判断这个数是否在 40亿个数中。</font>

> （方法一）用位图/Bitmap的方法，申请512M的内存，一个bit位代表一个unsigned int值。**读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。**
>
> （方法二）**把40亿个数中的每一个用32位的二进制来表示；假设这40亿个数开始放在一个文件中。**
>
>   将这40亿个数分成两类:
>    1.最高位为0
>    2.最高位为1
>   并将这两类分别写入到两个文件中，其中一个文件中数的个数<=20亿，而另一个>=20亿（这相当于折半了）；
> 与要查找的数的最高位比较并接着进入相应的文件再查找
>
>   再然后把这个文件为又分成两类:    1.次最高位为0    2.次最高位为1
>
>   并将这两类分别写入到两个文件中，其中一个文件中数的个数<=10亿，而另一个>=10亿（这相当于折半了）；   与要查找的数的次最高位比较并接着进入相应的文件再查找。   .......   以此类推，就可以找到了。
>
> **时间复杂度为O(logn)**



### ==布隆过滤器原理与优点==

布隆过滤器是一个比特向量或者比特数组，它本质上是一种概率型数据结构，**用来查找一个元素是否在集合中，**支持高效插入和查询某条记录。<font color=blue>常作为针对超大数据量下高效查找数据的一种方法。</font>

**它的具体工作过程是这样子的：**
假设**布隆过滤器的大小为m（比特向量的长度为m**），有**<font color=blue>k个哈希函数</font>，它对每个数据用这k个哈希函数计算哈希**，得到k个哈希值，然后**将向量中相应的位设为1**。在查询某个数据是否存在的时候，对这个数据用k个哈希函数得到k个哈希值，再在比特向量中相应的位查找是否为1，如果某一个相应的位不为1，那这个数据就肯定不存在。但是如果全找到了，则这个数据有可能存在。

**为什么说有可能存在呢？**
因为不同的数据经过哈希后可能有相同的哈希值，在比特向量上某个位置查找到1也可能是由于某个另外的数据映射得到的。

**支持删除操作吗**
<font color=blue>目前布隆过滤器只支持插入和查找操作，不支持删除操作</font>，如果要支持删除，就要另外使用一个计数变量，每次将相应的位置为1则计数加一，删除则减一。

<font color=red>**布隆过滤器的应用场景有很多，典型的有Redis的缓存穿透、爬虫时URL去重、垃圾邮件的判别等。**</font>



### ==Trie树==

Trie 树 又称 字典树，一种用于快速检索的多叉树结构。<font size=4 color=VioletRed>典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计</font>。**它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。**

   **Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。**

   **Trie树也有它的缺点**，Trie树的内存消耗非常大。当然,或许用左儿子右兄弟的方法建树的话，可能会好点。



### 如何在 10亿数据中快速找出 最大的前100个数？

- <font size=4>针对 TOP K类问题，比较好的解决方案是 <font color=VioletRed>**分治+ hash+小顶堆**</font>。即，先将 数据集按照  hash方法分解成多个小数据集，再使用 hash统计每个小数据集中的词频率，再 用小根堆  求每个小数据集的TOP K，再从所有的TOP K中，求出最终的 top k</font>

###  8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）美团一面



### 生成随机数问题：给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？

```
RandNN= N( RandN()-1 ) + RandN() ;  // 生成1到N^2之间的随机数
可以看作是在数轴上撒豆子。N是跨度/步长，是RandN()生成的数的范围长度，RandN()-1的目的是生成0到N-1的数，是跳数。后面+RandN()的目的是填满中间的空隙
```

比如：5 * (Rand5( ) - 1) + Rand5( ) ;   （可以得到 1~25 的数）

// Rand5 产生1 ~ 5的数，减1就产生0~4的数，乘以5后可以产生的数是：0,5,10,15,20。 再加上第二个Rand5()产生的1,2,3,4,5。我们可以得到1到25。

我们可以只要1到21（3*7）之间的数字，所以可以这么写

```
int rand7(){
  int x=INT_MAX;
  while(x>21){
    x=5*(rand5()-1)+rand5();
  }
  return x%7+1;
}
```

### 实现  ID 全局唯一且自增（雪花算法）

http://www.mianshigee.com/question/11985ipj

**雪花ID生成的是一个64位的二进制正整数，然后转换成10进制的数**。64位二进制数由如下部分组成：

- 1位标识符：始终是0（id 一般为正数，负数为 -1）
- **41位时间戳：存储时间截的差值**（当前时间截 - 开始时间截 ）
- 10位机器标识码：10位可以由 5位机房ID + 5位机器ID 组成。
- 12位序列：毫秒内的计数

<font size=4 color=blue>优 | 缺点</font>

优点：<font color=red>**时间戳在高位，自增序列在低位，整个ID是趋势递增的，按照时间有序递增。**</font>

缺点：**依赖机器的时钟**，如果服务器时钟回拨，会导致重复ID生成。



### 即时通讯系统中，如何保证接受方收到的消息，就是发送方发送的消息？

<font size=4 color=blue>发送方除了发送消息本身，还要发送消息的签名，接收方收到消息后要校验签名，以确保消息是完整的，未被篡改。</font>



------

# 消息中间件

###  消息中间件的组成

- <font color=purple size=4>**Broker：消息服务器**</font>，作为 server 提供消息核心服务；
- <font color=purple size=4>**Producer**</font>：消息生产者，负责 生产消息传输给  broker；
- <font color=purple size=4>**Consumer**</font>：消息 消费者，负责从 broker 获取消息并进行业务逻辑处理。
- <font color=purple size=4>**Topic**：主题，发布订阅模式下的消息汇集地</font>。不同生产者 向 topic 发送消息，**由   MQ  服务器分发到不同的订阅者，实现 消息的广播；**
- <font color=purple size=4>**Queue**</font>：队列，PTP模式下，特定生产者 向 特定queue 发送消息，消费者订阅 特定的queue，完成指定消息的接收；
- <font color=purple size=4>**Message**</font>：消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装 业务数据，实现消息的传输。

### 消息中间件的模式分类

1. <font size=4 color=red>**PTP 点对点**</font>

   PTP 点对点使用  <font color=red>**queue 作为通信载体**</font>；生产者将消息发送到 queue，消费者从 queue 取数据；消息被消费后，不再存储。Queue 支持多个消费者，但只有一个 消费者可以消息；

2. <font size=4 color=red> **发布 / 订阅**</font>

   <font color=red>**使用 topic 作为 通信载体**</font>；生产者 将消息发布到  topic 上，同时有 多个消息者 订阅（消费）该消息。

   queue 实现了 负载均衡；topic 实现了 发布订阅，所有 1 到 N个订阅者都能得到一个消息的拷贝。

### 为什么要用消息中间件？

<font size=4 color=blue>低耦合（系统解耦），低响应时间，异步调用。</font>

- <font color=red>异步处理：</font>

- 冗余：<font color=red>**消息队列 把数据进行持久化直到它们已经被完全处理，规避了  数据丢失风险。**</font>

- 可恢复性：**消息队列降低了进程间的耦合；即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理**。

- <font color=red>**流量削峰（重点）**</font>：（在   应用前端 加入 消息队列）

  - **可以控制活动人数，超过此一定阀值的订单直接丢弃**(我为什么秒杀一次都没有成功过呢^^)
  - 可以**缓解短时间的高流量**压垮应用（**应用程序按自己的最大处理能力获取订单**）

  

### 消费模式

消费模式分为<font size=4 color=blue>推（push）模式和拉（pull）模式</font>。<font color=red>**推（push）模式**</font>是指由<font size=4 >Broker主动推送消息至消费端，**实时性较好**，不过需要一定的**流控制机制来确保服务端推送过来的消息不会压垮消费端**</font>。而<font color=red>**拉（pull）模式**</font>是指消费端主动向Broker端请求拉取（一般是定时或者定量）消息，实时性 较 推（push）模式  差，但是<font size=4 >**可以根据自身的处理能力 来控制拉取的消息量**</font>。